--- Execution profile ---
Total samples       : 17778
unknown_Java        : 1 (0.01%)

--- 30150000000 ns (16.96%), 3015 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 21240000000 ns (11.95%), 2124 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 13980000000 ns (7.86%), 1398 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 13480000000 ns (7.58%), 1348 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 11090000000 ns (6.24%), 1109 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 10600000000 ns (5.96%), 1060 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 8370000000 ns (4.71%), 837 samples
  [ 0] io.ktor.benchmarks.SimpleDispatcher.getQueue
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 7540000000 ns (4.24%), 754 samples
  [ 0] io.ktor.benchmarks.SimpleDispatcher.getQueue
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 5470000000 ns (3.08%), 547 samples
  [ 0] jlong_disjoint_arraycopy
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 4960000000 ns (2.79%), 496 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 3660000000 ns (2.06%), 366 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 3590000000 ns (2.02%), 359 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 3470000000 ns (1.95%), 347 samples
  [ 0] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 3000000000 ns (1.69%), 300 samples
  [ 0] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 2810000000 ns (1.58%), 281 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 2460000000 ns (1.38%), 246 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 2270000000 ns (1.28%), 227 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 2190000000 ns (1.23%), 219 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 2130000000 ns (1.20%), 213 samples
  [ 0] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 2040000000 ns (1.15%), 204 samples
  [ 0] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 2030000000 ns (1.14%), 203 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 1650000000 ns (0.93%), 165 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 1540000000 ns (0.87%), 154 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.getNext
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 1480000000 ns (0.83%), 148 samples
  [ 0] kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 1480000000 ns (0.83%), 148 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 1350000000 ns (0.76%), 135 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 1040000000 ns (0.58%), 104 samples
  [ 0] read
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 930000000 ns (0.52%), 93 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.getNext
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 890000000 ns (0.50%), 89 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.<init>
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 840000000 ns (0.47%), 84 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 720000000 ns (0.40%), 72 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 610000000 ns (0.34%), 61 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 600000000 ns (0.34%), 60 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 560000000 ns (0.31%), 56 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 4] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 520000000 ns (0.29%), 52 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 510000000 ns (0.29%), 51 samples
  [ 0] kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 440000000 ns (0.25%), 44 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 420000000 ns (0.24%), 42 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 270000000 ns (0.15%), 27 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 220000000 ns (0.12%), 22 samples
  [ 0] jdk.internal.misc.Unsafe.checkOffset
  [ 1] jdk.internal.misc.Unsafe.checkPointer
  [ 2] jdk.internal.misc.Unsafe.checkPrimitivePointer
  [ 3] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 4] jdk.internal.misc.Unsafe.copyMemory
  [ 5] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 6] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 7] java.nio.ByteBuffer.putBuffer
  [ 8] java.nio.ByteBuffer.put
  [ 9] java.nio.HeapByteBuffer.put
  [10] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [12] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [13] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [14] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [15] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [16] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [17] kotlinx.coroutines.DispatchedTask.run
  [18] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [19] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 210000000 ns (0.12%), 21 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 210000000 ns (0.12%), 21 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 190000000 ns (0.11%), 19 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 180000000 ns (0.10%), 18 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.markPrev
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 3] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 4] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 140000000 ns (0.08%), 14 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 140000000 ns (0.08%), 14 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 140000000 ns (0.08%), 14 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.<init>
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 120000000 ns (0.07%), 12 samples
  [ 0] jdk.internal.misc.Unsafe.checkPrimitiveArray
  [ 1] jdk.internal.misc.Unsafe.checkPrimitivePointer
  [ 2] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 3] jdk.internal.misc.Unsafe.copyMemory
  [ 4] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 5] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 6] java.nio.ByteBuffer.putBuffer
  [ 7] java.nio.ByteBuffer.put
  [ 8] java.nio.HeapByteBuffer.put
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [12] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [13] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [14] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [15] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [16] kotlinx.coroutines.DispatchedTask.run
  [17] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [18] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 120000000 ns (0.07%), 12 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.flush
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 110000000 ns (0.06%), 11 samples
  [ 0] kotlin.jvm.internal.Intrinsics.areEqual
  [ 1] kotlin.coroutines.CoroutineContext$Element$DefaultImpls.get
  [ 2] kotlinx.coroutines.Job$DefaultImpls.get
  [ 3] kotlinx.coroutines.JobSupport.get
  [ 4] kotlin.coroutines.CombinedContext.get
  [ 5] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 6] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [12] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 100000000 ns (0.06%), 10 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 90000000 ns (0.05%), 9 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 90000000 ns (0.05%), 9 samples
  [ 0] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 90000000 ns (0.05%), 9 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 70000000 ns (0.04%), 7 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 70000000 ns (0.04%), 7 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 70000000 ns (0.04%), 7 samples
  [ 0] kotlinx.coroutines.DispatchedTask.run
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 60000000 ns (0.03%), 6 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] java.nio.Buffer.limit
  [ 1] java.nio.ByteBuffer.limit
  [ 2] java.nio.MappedByteBuffer.limit
  [ 3] java.nio.MappedByteBuffer.limit
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.addNext
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.markPrev
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 3] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 4] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] __open
  [ 1] handleOpen
  [ 2] fileOpen
  [ 3] java.io.RandomAccessFile.open0
  [ 4] java.io.RandomAccessFile.open
  [ 5] java.io.RandomAccessFile.<init>
  [ 6] java.io.RandomAccessFile.<init>
  [ 7] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 8] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 9] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] kotlinx.coroutines.internal.ThreadContextKt$countAll$1.invoke
  [ 1] kotlin.coroutines.CombinedContext.fold
  [ 2] kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 4] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 5] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 6] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [12] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.flush
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] __psynch_cvwait
  [ 1] os::PlatformMonitor::wait(long)
  [ 2] Monitor::wait(long long, bool)
  [ 3] CompileQueue::get()
  [ 4] CompileBroker::compiler_thread_loop()
  [ 5] JavaThread::thread_main_inner()
  [ 6] Thread::call_run()
  [ 7] thread_native_entry(Thread*)
  [ 8] __os_ch_md_redzone_cookie
  [ 9] internal_catch_exc_subsystem

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.<init>
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 2] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 3] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$flushImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 4] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 5] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 6] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] vtable stub
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.Job$DefaultImpls.get
  [ 1] kotlinx.coroutines.JobSupport.get
  [ 2] kotlin.coroutines.CombinedContext.get
  [ 3] io.ktor.utils.io.internal.CancellableReusableContinuation.parent
  [ 4] io.ktor.utils.io.internal.CancellableReusableContinuation.completeSuspendBlock
  [ 5] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 1] jdk.internal.misc.Unsafe.copyMemory
  [ 2] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 3] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 4] java.nio.ByteBuffer.putBuffer
  [ 5] java.nio.ByteBuffer.put
  [ 6] java.nio.HeapByteBuffer.put
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] sun.nio.ch.FileDispatcherImpl.read0
  [ 1] sun.nio.ch.FileDispatcherImpl.read
  [ 2] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 3] sun.nio.ch.IOUtil.read
  [ 4] sun.nio.ch.FileChannelImpl.read
  [ 5] io.ktor.util.BufferViewJvmKt.read
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.<init>
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.flush
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$getState
  [ 2] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] jdk.internal.misc.Unsafe.checkPrimitivePointer
  [ 1] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 2] jdk.internal.misc.Unsafe.copyMemory
  [ 3] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 4] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 5] java.nio.ByteBuffer.putBuffer
  [ 6] java.nio.ByteBuffer.put
  [ 7] java.nio.HeapByteBuffer.put
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [13] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [17] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.accessCheck
  [ 2] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 3] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.isClosedForRead
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.nio.Buffer.limit
  [ 1] java.nio.ByteBuffer.limit
  [ 2] java.nio.MappedByteBuffer.limit
  [ 3] java.nio.MappedByteBuffer.limit
  [ 4] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 5] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 6] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.ResultKt.throwOnFailure
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 1] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.markPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 3] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] sun.nio.ch.NativeThread.current
  [ 1] sun.nio.ch.NativeThreadSet.add
  [ 2] sun.nio.ch.FileChannelImpl.read
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 1] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.CompletionStateKt.toState
  [ 1] kotlinx.coroutines.CompletionStateKt.toState$default
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 4] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.core.ByteOrder.getNioOrder
  [ 1] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 2] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 2] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 1] kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] __psynch_cvbroad
  [ 1] CompileBroker::create_compile_task(CompileQueue*, int, methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, bool)
  [ 2] CompileBroker::compile_method_base(methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, bool, Thread*)
  [ 3] CompileBroker::compile_method(methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, DirectiveSet*, Thread*)
  [ 4] CompileBroker::compile_method(methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, Thread*)
  [ 5] TieredThresholdPolicy::compile(methodHandle const&, int, CompLevel, Thread*)
  [ 6] TieredThresholdPolicy::event(methodHandle const&, methodHandle const&, int, int, CompLevel, CompiledMethod*, Thread*)
  [ 7] InterpreterRuntime::frequency_counter_overflow_inner(JavaThread*, unsigned char*)
  [ 8] InterpreterRuntime::frequency_counter_overflow(JavaThread*, unsigned char*)
  [ 9] kotlinx.coroutines.internal.LockFreeLinkedListNode.getNextNode
  [10] kotlinx.coroutines.JobSupport.nextChild
  [11] kotlinx.coroutines.JobSupport.firstChild
  [12] kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath
  [13] kotlinx.coroutines.JobSupport.tryMakeCompleting
  [14] kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core
  [15] kotlinx.coroutines.AbstractCoroutine.resumeWith
  [16] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [17] kotlinx.coroutines.DispatchedTask.run
  [18] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [19] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 1] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.BlockingCoroutine.<init>
  [ 1] kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking
  [ 2] kotlinx.coroutines.BuildersKt.runBlocking
  [ 3] io.ktor.benchmarks.FileBenchmarks.testKtorFakeFileReadInSimple
  [ 4] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFakeFileReadInSimple_jmhTest.testKtorFakeFileReadInSimple_avgt_jmhStub
  [ 5] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFakeFileReadInSimple_jmhTest.testKtorFakeFileReadInSimple_AverageTime
  [ 6] jdk.internal.reflect.NativeMethodAccessorImpl.invoke0
  [ 7] jdk.internal.reflect.NativeMethodAccessorImpl.invoke
  [ 8] jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke
  [ 9] java.lang.reflect.Method.invoke
  [10] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [11] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.Executors$RunnableAdapter.call
  [14] java.util.concurrent.FutureTask.run
  [15] java.util.concurrent.ThreadPoolExecutor.runWorker
  [16] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [17] java.lang.Thread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] __psynch_mutexwait
  [ 1] err_codes_iokit_usb
  [ 2] __os_ch_md_redzone_cookie
  [ 3] os::PlatformMonitor::wait(long)
  [ 4] Monitor::wait(long long, bool)
  [ 5] CompileQueue::get()
  [ 6] CompileBroker::compiler_thread_loop()
  [ 7] JavaThread::thread_main_inner()
  [ 8] Thread::call_run()
  [ 9] thread_native_entry(Thread*)
  [10] __os_ch_md_redzone_cookie
  [11] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] _platform_strchr$VARIANT$Haswell
  [ 1] outputStream::print(char const*, ...)
  [ 2] CompileTask::print_impl(outputStream*, Method*, int, int, bool, int, bool, char const*, bool, bool, long, long)
  [ 3] CompileTask::print(outputStream*, char const*, bool, bool)
  [ 4] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 5] CompileBroker::compiler_thread_loop()
  [ 6] JavaThread::thread_main_inner()
  [ 7] Thread::call_run()
  [ 8] thread_native_entry(Thread*)
  [ 9] __os_ch_md_redzone_cookie
  [10] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.removed
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.markPrev
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 3] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 4] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.accessCheck
  [ 2] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 3] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeClosed
  [ 5] io.ktor.utils.io.ByteBufferChannel.close
  [ 6] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [ 7] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [ 8] kotlinx.coroutines.InvokeOnCompletion.invoke
  [ 9] kotlinx.coroutines.JobSupport.notifyCompletion
  [10] kotlinx.coroutines.JobSupport.completeStateFinalization
  [11] kotlinx.coroutines.JobSupport.finalizeFinishingState
  [12] kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath
  [13] kotlinx.coroutines.JobSupport.tryMakeCompleting
  [14] kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core
  [15] kotlinx.coroutines.AbstractCoroutine.resumeWith
  [16] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [17] kotlinx.coroutines.DispatchedTask.run
  [18] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [19] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] [unknown]
  [ 1] ResourceBitMap::ResourceBitMap(unsigned long, bool)
  [ 2] ComputeLinearScanOrder::ComputeLinearScanOrder(Compilation*, BlockBegin*)
  [ 3] IR::compute_code()
  [ 4] Compilation::build_hir()
  [ 5] Compilation::compile_java_method()
  [ 6] Compilation::compile_method()
  [ 7] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 8] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 9] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [10] CompileBroker::compiler_thread_loop()
  [11] JavaThread::thread_main_inner()
  [12] Thread::call_run()
  [13] thread_native_entry(Thread*)
  [14] __os_ch_md_redzone_cookie
  [15] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.CoroutinesKt.launchChannel
  [ 1] io.ktor.utils.io.CoroutinesKt.writer
  [ 2] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 3] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 4] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.DirectByteBuffer.<init>
  [ 1] java.nio.DirectByteBuffer.slice
  [ 2] io.ktor.utils.io.core.IoBuffer.<init>
  [ 3] io.ktor.utils.io.internal.WriteSessionImpl.begin
  [ 4] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [ 9] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] SpinPause
  [ 1] SafepointSynchronize::disarm_safepoint()
  [ 2] SafepointSynchronize::end()
  [ 3] VMThread::inner_execute(VM_Operation*)
  [ 4] VMThread::run()
  [ 5] Thread::call_run()
  [ 6] thread_native_entry(Thread*)
  [ 7] __os_ch_md_redzone_cookie
  [ 8] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] os::PlatformMonitor::wait(long)
  [ 1] Monitor::wait_without_safepoint_check(long long)
  [ 2] WatcherThread::sleep() const
  [ 3] WatcherThread::run()
  [ 4] Thread::call_run()
  [ 5] thread_native_entry(Thread*)
  [ 6] __os_ch_md_redzone_cookie
  [ 7] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] GrowableArrayWithAllocator<CodeStub*, GrowableArray<CodeStub*> >::grow(int)
  [ 1] LIR_Assembler::add_debug_info_for_null_check(int, CodeEmitInfo*)
  [ 2] LIR_Assembler::reg2mem(LIR_OprDesc*, LIR_OprDesc*, BasicType, LIR_PatchCode, CodeEmitInfo*, bool, bool, bool)
  [ 3] LIR_Assembler::move_op(LIR_OprDesc*, LIR_OprDesc*, BasicType, LIR_PatchCode, CodeEmitInfo*, bool, bool, bool)
  [ 4] LIR_Assembler::emit_op1(LIR_Op1*)
  [ 5] LIR_Assembler::emit_lir_list(LIR_List*)
  [ 6] LIR_Assembler::emit_code(BlockList*)
  [ 7] Compilation::emit_code_body()
  [ 8] Compilation::compile_java_method()
  [ 9] Compilation::compile_method()
  [10] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [11] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [12] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [13] CompileBroker::compiler_thread_loop()
  [14] JavaThread::thread_main_inner()
  [15] Thread::call_run()
  [16] thread_native_entry(Thread*)
  [17] __os_ch_md_redzone_cookie
  [18] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] __psynch_cvbroad
  [ 1] CompileBroker::create_compile_task(CompileQueue*, int, methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, bool)
  [ 2] CompileBroker::compile_method_base(methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, bool, Thread*)
  [ 3] CompileBroker::compile_method(methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, DirectiveSet*, Thread*)
  [ 4] CompileBroker::compile_method(methodHandle const&, int, int, methodHandle const&, int, CompileTask::CompileReason, Thread*)
  [ 5] TieredThresholdPolicy::compile(methodHandle const&, int, CompLevel, Thread*)
  [ 6] TieredThresholdPolicy::event(methodHandle const&, methodHandle const&, int, int, CompLevel, CompiledMethod*, Thread*)
  [ 7] InterpreterRuntime::frequency_counter_overflow_inner(JavaThread*, unsigned char*)
  [ 8] InterpreterRuntime::frequency_counter_overflow(JavaThread*, unsigned char*)
  [ 9] java.lang.invoke.VarHandle.isDirect
  [10] java.lang.invoke.VarHandleGuards.guard_LLL_Z
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListKt.unwrap
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] jdk.internal.misc.Unsafe.copyMemory
  [ 1] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 2] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 3] java.nio.ByteBuffer.putBuffer
  [ 4] java.nio.ByteBuffer.put
  [ 5] java.nio.HeapByteBuffer.put
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] MethodLiveness::BasicBlock::compute_gen_kill_single(ciBytecodeStream*)
  [ 1] MethodLiveness::BasicBlock::compute_gen_kill_range(ciBytecodeStream*)
  [ 2] MethodLiveness::compute_liveness()
  [ 3] ciMethod::bci_block_start()
  [ 4] BlockListBuilder::set_leaders()
  [ 5] BlockListBuilder::BlockListBuilder(Compilation*, IRScope*, int)
  [ 6] GraphBuilder::GraphBuilder(Compilation*, IRScope*)
  [ 7] IRScope::IRScope(Compilation*, IRScope*, int, ciMethod*, int, bool)
  [ 8] IR::IR(Compilation*, ciMethod*, int)
  [ 9] Compilation::build_hir()
  [10] Compilation::compile_java_method()
  [11] Compilation::compile_method()
  [12] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [13] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [14] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [15] CompileBroker::compiler_thread_loop()
  [16] JavaThread::thread_main_inner()
  [17] Thread::call_run()
  [18] thread_native_entry(Thread*)
  [19] __os_ch_md_redzone_cookie
  [20] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.lazySet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.addNext
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.ByteBuffer.position
  [ 1] java.nio.MappedByteBuffer.position
  [ 2] java.nio.MappedByteBuffer.position
  [ 3] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 4] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 5] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 1] kotlinx.coroutines.DispatchedTask.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] CodeHeap::find_blob_unsafe(void*) const
  [ 1] CodeCache::find_blob(void*)
  [ 2] frame::sender_for_compiled_frame(RegisterMap*) const
  [ 3] frame::sender_raw(RegisterMap*) const
  [ 4] frame::sender(RegisterMap*) const
  [ 5] java_lang_Throwable::fill_in_stack_trace(Handle, methodHandle const&, Thread*)
  [ 6] java_lang_Throwable::fill_in_stack_trace(Handle, methodHandle const&)
  [ 7] JVM_FillInStackTrace
  [ 8] Java_java_lang_Throwable_fillInStackTrace
  [ 9] java.lang.Throwable.fillInStackTrace
  [10] java.lang.Throwable.fillInStackTrace
  [11] java.lang.Throwable.<init>
  [12] java.lang.Exception.<init>
  [13] java.lang.RuntimeException.<init>
  [14] java.lang.IllegalStateException.<init>
  [15] java.util.concurrent.CancellationException.<init>
  [16] io.ktor.utils.io.ClosedWriteChannelException.<init>
  [17] io.ktor.utils.io.ByteBufferChannel.close
  [18] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [19] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [20] kotlinx.coroutines.InvokeOnCompletion.invoke
  [21] kotlinx.coroutines.JobSupport.notifyCompletion
  [22] kotlinx.coroutines.JobSupport.completeStateFinalization
  [23] kotlinx.coroutines.JobSupport.finalizeFinishingState
  [24] kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath
  [25] kotlinx.coroutines.JobSupport.tryMakeCompleting
  [26] kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core
  [27] kotlinx.coroutines.AbstractCoroutine.resumeWith
  [28] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [29] kotlinx.coroutines.DispatchedTask.run
  [30] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [31] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] jdk.internal.misc.Unsafe.checkPrimitivePointer
  [ 1] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 2] jdk.internal.misc.Unsafe.copyMemory
  [ 3] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 4] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 5] java.nio.ByteBuffer.putBuffer
  [ 6] java.nio.ByteBuffer.put
  [ 7] java.nio.HeapByteBuffer.put
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [13] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [17] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.writeSuspendPredicate
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$writeSuspendPredicate
  [ 3] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 4] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 5] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 6] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListKt.unwrap
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 2] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] GlobalValueNumbering::GlobalValueNumbering(IR*)
  [ 1] Compilation::build_hir()
  [ 2] Compilation::compile_java_method()
  [ 3] Compilation::compile_method()
  [ 4] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 5] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 6] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 7] CompileBroker::compiler_thread_loop()
  [ 8] JavaThread::thread_main_inner()
  [ 9] Thread::call_run()
  [10] thread_native_entry(Thread*)
  [11] __os_ch_md_redzone_cookie
  [12] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.ReadWriteBufferState$Writing.startReading$ktor_io
  [ 1] io.ktor.utils.io.internal.ReadWriteBufferState$Writing.startReading$ktor_io
  [ 2] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] fdval
  [ 1] Java_sun_nio_ch_FileDispatcherImpl_read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read0
  [ 3] sun.nio.ch.FileDispatcherImpl.read
  [ 4] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 5] sun.nio.ch.IOUtil.read
  [ 6] sun.nio.ch.FileChannelImpl.read
  [ 7] io.ktor.util.BufferViewJvmKt.read
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking
  [ 1] kotlinx.coroutines.BuildersKt.runBlocking
  [ 2] io.ktor.benchmarks.FileBenchmarks.testKtorFakeFileReadInSimple
  [ 3] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFakeFileReadInSimple_jmhTest.testKtorFakeFileReadInSimple_avgt_jmhStub
  [ 4] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFakeFileReadInSimple_jmhTest.testKtorFakeFileReadInSimple_AverageTime
  [ 5] jdk.internal.reflect.NativeMethodAccessorImpl.invoke0
  [ 6] jdk.internal.reflect.NativeMethodAccessorImpl.invoke
  [ 7] jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke
  [ 8] java.lang.reflect.Method.invoke
  [ 9] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [10] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.Executors$RunnableAdapter.call
  [13] java.util.concurrent.FutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] __unlink
  [ 1] [unknown]
  [ 2] Java_java_io_UnixFileSystem_delete0
  [ 3] java.io.UnixFileSystem.delete0
  [ 4] java.io.UnixFileSystem.delete
  [ 5] java.io.File.delete
  [ 6] io.ktor.benchmarks.FileBenchmarks.cleanup
  [ 7] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFakeFileReadInSimple_jmhTest.testKtorFakeFileReadInSimple_AverageTime
  [ 8] jdk.internal.reflect.NativeMethodAccessorImpl.invoke0
  [ 9] jdk.internal.reflect.NativeMethodAccessorImpl.invoke
  [10] jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke
  [11] java.lang.reflect.Method.invoke
  [12] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [13] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [14] java.util.concurrent.FutureTask.run
  [15] java.util.concurrent.Executors$RunnableAdapter.call
  [16] java.util.concurrent.FutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.position
  [ 1] java.nio.ByteBuffer.position
  [ 2] java.nio.MappedByteBuffer.position
  [ 3] java.nio.MappedByteBuffer.position
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 2] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.restoreStateAfterWrite$ktor_io
  [ 1] io.ktor.utils.io.internal.WriteSessionImpl.complete
  [ 2] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel$writeSuspendSession$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.jvm.internal.Intrinsics.checkNotNull
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] __psynch_cvwait
  [ 1] os::PlatformMonitor::wait(long)
  [ 2] Monitor::wait_without_safepoint_check(long long)
  [ 3] WatcherThread::sleep() const
  [ 4] WatcherThread::run()
  [ 5] Thread::call_run()
  [ 6] thread_native_entry(Thread*)
  [ 7] __os_ch_md_redzone_cookie
  [ 8] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 1] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 2] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.lang.Integer.intValue
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] JavaThreadParkedState::JavaThreadParkedState(JavaThread*, bool)
  [ 1] Unsafe_Park(JNIEnv_*, _jobject*, unsigned char, long)
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly
  [ 6] java.util.concurrent.CountDownLatch.await
  [ 7] org.openjdk.jmh.runner.InfraControlL2.awaitWarmdownReady
  [ 8] org.openjdk.jmh.runner.InfraControl.awaitWarmdownReady
  [ 9] org.openjdk.jmh.runner.BenchmarkHandler.runIteration
  [10] org.openjdk.jmh.runner.BaseRunner.runBenchmark
  [11] org.openjdk.jmh.runner.BaseRunner.runBenchmark
  [12] org.openjdk.jmh.runner.BaseRunner.doSingle
  [13] org.openjdk.jmh.runner.BaseRunner.runBenchmarksForked
  [14] org.openjdk.jmh.runner.ForkedRunner.run
  [15] org.openjdk.jmh.runner.ForkedMain.main

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 2] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
  [ 1] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.flush
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] __psynch_cvwait
  [ 1] os::PlatformMonitor::wait(long)
  [ 2] Monitor::wait_without_safepoint_check(long long)
  [ 3] G1ServiceThread::sleep_before_next_cycle()
  [ 4] G1ServiceThread::run_service()
  [ 5] ConcurrentGCThread::run()
  [ 6] Thread::call_run()
  [ 7] thread_native_entry(Thread*)
  [ 8] __os_ch_md_redzone_cookie
  [ 9] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] PhaseChaitin::Select()
  [ 1] PhaseChaitin::Register_Allocate()
  [ 2] Compile::Code_Gen()
  [ 3] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 4] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 5] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 6] CompileBroker::compiler_thread_loop()
  [ 7] JavaThread::thread_main_inner()
  [ 8] Thread::call_run()
  [ 9] thread_native_entry(Thread*)
  [10] __os_ch_md_redzone_cookie
  [11] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] unsafe_arraycopy
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.CoroutineContext$plus$1.invoke
  [ 1] kotlin.coroutines.CoroutineContext$plus$1.invoke
  [ 2] kotlin.coroutines.CoroutineContext$Element$DefaultImpls.fold
  [ 3] kotlin.coroutines.AbstractCoroutineContextElement.fold
  [ 4] kotlin.coroutines.CombinedContext.fold
  [ 5] kotlin.coroutines.CoroutineContext$DefaultImpls.plus
  [ 6] kotlin.coroutines.CombinedContext.plus
  [ 7] kotlinx.coroutines.CoroutineContextKt.newCoroutineContext
  [ 8] kotlinx.coroutines.BuildersKt__Builders_commonKt.launch
  [ 9] kotlinx.coroutines.BuildersKt.launch
  [10] kotlinx.coroutines.BuildersKt__Builders_commonKt.launch$default
  [11] kotlinx.coroutines.BuildersKt.launch$default
  [12] io.ktor.utils.io.CoroutinesKt.launchChannel
  [13] io.ktor.utils.io.CoroutinesKt.writer
  [14] io.ktor.util.cio.FileChannelsKt.readChannel
  [15] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [16] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [17] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [18] kotlinx.coroutines.DispatchedTask.run
  [19] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [20] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.position
  [ 1] java.nio.ByteBuffer.position
  [ 2] java.nio.MappedByteBuffer.position
  [ 3] java.nio.MappedByteBuffer.position
  [ 4] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 5] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.markPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 3] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.ByteBuffer.order
  [ 1] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 2] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 3] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 1] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 2] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] Profiler::CompiledMethodLoad(_jvmtiEnv*, _jmethodID*, int, void const*, int, _jvmtiAddrLocationMap const*, void const*)
  [ 1] JvmtiExport::post_compiled_method_load(nmethod*)
  [ 2] ServiceThread::service_thread_entry(JavaThread*, Thread*)
  [ 3] JavaThread::thread_main_inner()
  [ 4] Thread::call_run()
  [ 5] thread_native_entry(Thread*)
  [ 6] __os_ch_md_redzone_cookie
  [ 7] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] slow_subtype_check Runtime1 stub
  [ 1] [unknown_Java]

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.limit
  [ 1] java.nio.ByteBuffer.limit
  [ 2] java.nio.MappedByteBuffer.limit
  [ 3] java.nio.MappedByteBuffer.limit
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.lang.Object.equals
  [ 1] kotlin.jvm.internal.Intrinsics.areEqual
  [ 2] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 1] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run

          ns  percent  samples  top
  ----------  -------  -------  ---
 69000000000   38.81%     6900  io.ktor.benchmarks.IOCoroutineDispatcher$IOThread.run
 62190000000   34.98%     6219  java.util.concurrent.ConcurrentLinkedQueue.poll
 15910000000    8.95%     1591  io.ktor.benchmarks.SimpleDispatcher.getQueue
 10640000000    5.98%     1064  io.ktor.benchmarks.SimpleDispatcher.thread$lambda-0
  5470000000    3.08%      547  jlong_disjoint_arraycopy
  2470000000    1.39%      247  io.ktor.util.internal.LockFreeLinkedListNode.getNext
  2000000000    1.12%      200  kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  1050000000    0.59%      105  io.ktor.util.internal.LockFreeLinkedListNode.<init>
  1040000000    0.58%      104  read
   980000000    0.55%       98  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
   820000000    0.46%       82  io.ktor.utils.io.ByteBufferChannel.setupStateForRead
   630000000    0.35%       63  io.ktor.utils.io.ByteBufferChannel.suspensionForSize
   570000000    0.32%       57  io.ktor.util.internal.LockFreeLinkedListNode.addLast
   530000000    0.30%       53  io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
   270000000    0.15%       27  kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
   270000000    0.15%       27  itable stub
   270000000    0.15%       27  kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
   240000000    0.13%       24  io.ktor.util.internal.LockFreeLinkedListNode.remove
   220000000    0.12%       22  jdk.internal.misc.Unsafe.checkOffset
   150000000    0.08%       15  io.ktor.benchmarks.IOCoroutineDispatcher.dispatch
   150000000    0.08%       15  io.ktor.utils.io.ByteBufferChannel.resumeReadOp
   130000000    0.07%       13  io.ktor.benchmarks.FileBenchmarks$testKtorFakeFileReadInSimple$1.invokeSuspend
   120000000    0.07%       12  jdk.internal.misc.Unsafe.checkPrimitiveArray
   120000000    0.07%       12  io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
   110000000    0.06%       11  kotlin.jvm.internal.Intrinsics.areEqual
   110000000    0.06%       11  kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
   100000000    0.06%       10  io.ktor.utils.io.ByteBufferChannel.bytesRead
   100000000    0.06%       10  io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
   100000000    0.06%       10  io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.run
   100000000    0.06%       10  io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
    80000000    0.04%        8  java.nio.Buffer.limit
    70000000    0.04%        7  __psynch_cvwait
    70000000    0.04%        7  kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
    70000000    0.04%        7  io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
    70000000    0.04%        7  kotlinx.coroutines.DispatchedTask.run
    60000000    0.03%        6  kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
    60000000    0.03%        6  kotlin.coroutines.CombinedContext.get
    50000000    0.03%        5  io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
    50000000    0.03%        5  kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
    50000000    0.03%        5  io.ktor.benchmarks.IOCoroutineDispatcher$IODispatchedTask.<init>
    50000000    0.03%        5  kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
    50000000    0.03%        5  io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
    40000000    0.02%        4  kotlinx.coroutines.internal.ThreadContextKt$countAll$1.invoke
    40000000    0.02%        4  __open
    40000000    0.02%        4  io.ktor.utils.io.ByteBufferChannel.getState
    40000000    0.02%        4  [unknown]
    40000000    0.02%        4  io.ktor.utils.io.ByteBufferChannel.prepareBuffer
    30000000    0.02%        3  io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
    30000000    0.02%        3  io.ktor.util.internal.LockFreeLinkedListNode.markPrev
    30000000    0.02%        3  vtable stub
    30000000    0.02%        3  kotlin.coroutines.jvm.internal.BaseContinuationImpl.<init>
    30000000    0.02%        3  jdk.internal.misc.Unsafe.checkPrimitivePointer
    20000000    0.01%        2  __psynch_cvbroad
    20000000    0.01%        2  kotlin.ResultKt.throwOnFailure
    20000000    0.01%        2  io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
    20000000    0.01%        2  io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
    20000000    0.01%        2  kotlinx.coroutines.CompletionStateKt.toState
    20000000    0.01%        2  jdk.internal.misc.Unsafe.copyMemoryChecks
    20000000    0.01%        2  io.ktor.utils.io.core.ByteOrder.getNioOrder
    20000000    0.01%        2  kotlinx.coroutines.Job$DefaultImpls.get
    20000000    0.01%        2  io.ktor.util.internal.LockFreeLinkedListKt.unwrap
    20000000    0.01%        2  java.nio.ByteBuffer.order
    20000000    0.01%        2  sun.nio.ch.FileDispatcherImpl.read0
    20000000    0.01%        2  io.ktor.utils.io.internal.WriteSessionImpl.request
    20000000    0.01%        2  java.nio.Buffer.position
    20000000    0.01%        2  sun.nio.ch.NativeThread.current
    20000000    0.01%        2  io.ktor.utils.io.ByteBufferChannel.isClosedForRead
    10000000    0.01%        1  java.lang.Integer.intValue
    10000000    0.01%        1  java.lang.Object.equals
    10000000    0.01%        1  java.io.Bits.putDouble
    10000000    0.01%        1  io.ktor.utils.io.pool.DefaultPool.tryPop
    10000000    0.01%        1  io.ktor.utils.io.internal.RingBufferCapacity.completeRead
    10000000    0.01%        1  java.nio.ByteBuffer.position
    10000000    0.01%        1  java.nio.ByteBuffer.put
    10000000    0.01%        1  java.nio.DirectByteBuffer.<init>
    10000000    0.01%        1  BlockBegin::try_merge(ValueStack*)
    10000000    0.01%        1  java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
    10000000    0.01%        1  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
    10000000    0.01%        1  io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
    10000000    0.01%        1  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.lazySet
    10000000    0.01%        1  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.valueCheck
    10000000    0.01%        1  io.ktor.utils.io.CoroutinesKt.launchChannel
    10000000    0.01%        1  io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.create
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.restoreStateAfterWrite$ktor_io
    10000000    0.01%        1  jdk.internal.misc.Unsafe.copyMemory
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
    10000000    0.01%        1  jlong_arraycopy
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.getClosed
    10000000    0.01%        1  jni_EnsureLocalCapacity
    10000000    0.01%        1  jni_GetObjectField
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
    10000000    0.01%        1  io.ktor.util.internal.LockFreeLinkedListNode.removed
    10000000    0.01%        1  kotlin.coroutines.CoroutineContext$plus$1.invoke
    10000000    0.01%        1  fdval
    10000000    0.01%        1  close
    10000000    0.01%        1  ciMethodData::bci_to_data(int, ciMethod*)
    10000000    0.01%        1  _platform_strchr$VARIANT$Haswell
    10000000    0.01%        1  __unlink
    10000000    0.01%        1  __psynch_mutexwait
    10000000    0.01%        1  kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
    10000000    0.01%        1  __gettimeofday
    10000000    0.01%        1  SpinPause
    10000000    0.01%        1  kotlin.jvm.internal.Intrinsics.checkNotNull
    10000000    0.01%        1  kotlinx.coroutines.BlockingCoroutine.<init>
    10000000    0.01%        1  kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking
    10000000    0.01%        1  Profiler::CompiledMethodLoad(_jvmtiEnv*, _jmethodID*, int, void const*, int, _jvmtiAddrLocationMap const*, void const*)
    10000000    0.01%        1  kotlinx.coroutines.CoroutineDispatcher.releaseInterceptedContinuation
    10000000    0.01%        1  PhaseIdealLoop::get_early_ctrl(Node*)
    10000000    0.01%        1  PhaseChaitin::Select()
    10000000    0.01%        1  kotlinx.coroutines.internal.AtomicOp.perform
    10000000    0.01%        1  MethodLiveness::BasicBlock::compute_gen_kill_single(ciBytecodeStream*)
    10000000    0.01%        1  JavaThreadParkedState::JavaThreadParkedState(JavaThread*, bool)
    10000000    0.01%        1  IntervalWalker::walk_to(int)
    10000000    0.01%        1  os::PlatformMonitor::wait(long)
    10000000    0.01%        1  GrowableArrayWithAllocator<CodeStub*, GrowableArray<CodeStub*> >::grow(int)
    10000000    0.01%        1  slow_subtype_check Runtime1 stub
    10000000    0.01%        1  stat$INODE64
    10000000    0.01%        1  GlobalValueNumbering::GlobalValueNumbering(IR*)
    10000000    0.01%        1  CodeHeap::find_blob_unsafe(void*) const
    10000000    0.01%        1  unsafe_arraycopy
    10000000    0.01%        1  io.ktor.utils.io.internal.ReadWriteBufferState$Writing.startReading$ktor_io

