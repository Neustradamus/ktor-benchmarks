--- Execution profile ---
Total samples       : 17818
unknown_Java        : 2 (0.01%)
deoptimization      : 1 (0.01%)

--- 66740000000 ns (37.46%), 6674 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 14040000000 ns (7.88%), 1404 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 13890000000 ns (7.80%), 1389 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 10870000000 ns (6.10%), 1087 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 10350000000 ns (5.81%), 1035 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 8070000000 ns (4.53%), 807 samples
  [ 0] io.ktor.benchmarks.dispatchers.SimpleDispatcher.getQueue
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 7910000000 ns (4.44%), 791 samples
  [ 0] io.ktor.benchmarks.dispatchers.SimpleDispatcher.getQueue
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 5500000000 ns (3.09%), 550 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 4110000000 ns (2.31%), 411 samples
  [ 0] jlong_disjoint_arraycopy
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 3970000000 ns (2.23%), 397 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 3610000000 ns (2.03%), 361 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 3320000000 ns (1.86%), 332 samples
  [ 0] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 3210000000 ns (1.80%), 321 samples
  [ 0] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 2160000000 ns (1.21%), 216 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 2040000000 ns (1.14%), 204 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 1980000000 ns (1.11%), 198 samples
  [ 0] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 1870000000 ns (1.05%), 187 samples
  [ 0] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 2] java.lang.Thread.run

--- 1260000000 ns (0.71%), 126 samples
  [ 0] kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 1090000000 ns (0.61%), 109 samples
  [ 0] read
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 1010000000 ns (0.57%), 101 samples
  [ 0] jlong_disjoint_arraycopy
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 850000000 ns (0.48%), 85 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 830000000 ns (0.47%), 83 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 700000000 ns (0.39%), 70 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.SimpleDispatcher$$Lambda$45.0x0000000800c2a2f0.run
  [ 3] java.lang.Thread.run

--- 530000000 ns (0.30%), 53 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.getNext
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.getPrev
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 460000000 ns (0.26%), 46 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.<init>
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 450000000 ns (0.25%), 45 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 340000000 ns (0.19%), 34 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 330000000 ns (0.19%), 33 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 320000000 ns (0.18%), 32 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 280000000 ns (0.16%), 28 samples
  [ 0] kotlinx.coroutines.JobSupport.getKey
  [ 1] kotlin.coroutines.CoroutineContext$Element$DefaultImpls.get
  [ 2] kotlinx.coroutines.Job$DefaultImpls.get
  [ 3] kotlinx.coroutines.JobSupport.get
  [ 4] kotlin.coroutines.CombinedContext.get
  [ 5] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 6] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [12] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 260000000 ns (0.15%), 26 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 260000000 ns (0.15%), 26 samples
  [ 0] java.nio.ByteBuffer.put
  [ 1] java.nio.HeapByteBuffer.put
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 250000000 ns (0.14%), 25 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 230000000 ns (0.13%), 23 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.addNext
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 230000000 ns (0.13%), 23 samples
  [ 0] java.nio.ByteBuffer.putBuffer
  [ 1] java.nio.ByteBuffer.put
  [ 2] java.nio.HeapByteBuffer.put
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 210000000 ns (0.12%), 21 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 200000000 ns (0.11%), 20 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 160000000 ns (0.09%), 16 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.<init>
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 150000000 ns (0.08%), 15 samples
  [ 0] jlong_disjoint_arraycopy
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 150000000 ns (0.08%), 15 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 130000000 ns (0.07%), 13 samples
  [ 0] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 110000000 ns (0.06%), 11 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.markPrev
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 3] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 4] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 90000000 ns (0.05%), 9 samples
  [ 0] java.nio.ByteBuffer.putBuffer
  [ 1] java.nio.ByteBuffer.put
  [ 2] java.nio.HeapByteBuffer.put
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 90000000 ns (0.05%), 9 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 80000000 ns (0.04%), 8 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.flush
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 80000000 ns (0.04%), 8 samples
  [ 0] kotlin.jvm.internal.Intrinsics.checkNotNullParameter
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 4] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 70000000 ns (0.04%), 7 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 60000000 ns (0.03%), 6 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 60000000 ns (0.03%), 6 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.<init>
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 2] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 3] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 60000000 ns (0.03%), 6 samples
  [ 0] __psynch_cvwait
  [ 1] Parker::park(bool, long)
  [ 2] Unsafe_Park(JNIEnv_*, _jobject*, unsigned char, long)
  [ 3] jdk.internal.misc.Unsafe.park
  [ 4] java.util.concurrent.locks.LockSupport.parkNanos
  [ 5] kotlinx.coroutines.BlockingCoroutine.joinBlocking
  [ 6] kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking
  [ 7] kotlinx.coroutines.BuildersKt.runBlocking
  [ 8] io.ktor.benchmarks.FileBenchmarks.testKtorFileReadInIo2IoDispatcher
  [ 9] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_avgt_jmhStub
  [10] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_AverageTime
  [11] jdk.internal.reflect.NativeMethodAccessorImpl.invoke0
  [12] jdk.internal.reflect.NativeMethodAccessorImpl.invoke
  [13] jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke
  [14] java.lang.reflect.Method.invoke
  [15] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [16] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [17] java.util.concurrent.FutureTask.run
  [18] java.util.concurrent.Executors$RunnableAdapter.call
  [19] java.util.concurrent.FutureTask.run
  [20] java.util.concurrent.ThreadPoolExecutor.runWorker
  [21] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [22] java.lang.Thread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 50000000 ns (0.03%), 5 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 1] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 2] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.utils.io.core.Buffer.getLimit
  [ 1] io.ktor.utils.io.core.Buffer.commitWrittenUntilIndex
  [ 2] io.ktor.utils.io.core.IoBuffer.resetFromContentToWrite
  [ 3] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] sun.nio.ch.NativeThread.current
  [ 1] sun.nio.ch.NativeThreadSet.add
  [ 2] sun.nio.ch.FileChannelImpl.read
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 40000000 ns (0.02%), 4 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$getState
  [ 2] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] __open
  [ 1] handleOpen
  [ 2] fileOpen
  [ 3] java.io.RandomAccessFile.open0
  [ 4] java.io.RandomAccessFile.open
  [ 5] java.io.RandomAccessFile.<init>
  [ 6] java.io.RandomAccessFile.<init>
  [ 7] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 8] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 9] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.getContext
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 2] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 3] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 4] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 5] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] java.nio.Buffer.limit
  [ 1] java.nio.ByteBuffer.limit
  [ 2] java.nio.MappedByteBuffer.limit
  [ 3] java.nio.MappedByteBuffer.limit
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] sun.nio.ch.FileChannelImpl.read
  [ 1] io.ktor.util.BufferViewJvmKt.read
  [ 2] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] __psynch_cvwait
  [ 1] os::PlatformMonitor::wait(long)
  [ 2] Monitor::wait_without_safepoint_check(long long)
  [ 3] G1ServiceThread::sleep_before_next_cycle()
  [ 4] G1ServiceThread::run_service()
  [ 5] ConcurrentGCThread::run()
  [ 6] Thread::call_run()
  [ 7] thread_native_entry(Thread*)
  [ 8] __os_ch_md_redzone_cookie
  [ 9] internal_catch_exc_subsystem

--- 30000000 ns (0.02%), 3 samples
  [ 0] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 1] jdk.internal.misc.Unsafe.copyMemory
  [ 2] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 3] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 4] java.nio.ByteBuffer.putBuffer
  [ 5] java.nio.ByteBuffer.put
  [ 6] java.nio.HeapByteBuffer.put
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 30000000 ns (0.02%), 3 samples
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.ResultKt.throwOnFailure
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.nio.HeapByteBuffer.put
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
  [ 1] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] Interpreter
  [ 1] [unknown_Java]

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.jvm.internal.Intrinsics.checkNotNullParameter
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] jdk.internal.misc.Unsafe.copyMemory
  [ 1] jdk.internal.misc.ScopedMemoryAccess.copyMemoryInternal
  [ 2] jdk.internal.misc.ScopedMemoryAccess.copyMemory
  [ 3] java.nio.ByteBuffer.putBuffer
  [ 4] java.nio.ByteBuffer.put
  [ 5] java.nio.HeapByteBuffer.put
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] vtable stub
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 1] io.ktor.utils.io.ByteBufferChannel.prepareWriteBuffer$ktor_io
  [ 2] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.nio.channels.spi.AbstractInterruptibleChannel.begin
  [ 1] sun.nio.ch.FileChannelImpl.beginBlocking
  [ 2] sun.nio.ch.FileChannelImpl.read
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] sun.nio.ch.FileDispatcherImpl.read0
  [ 1] sun.nio.ch.FileDispatcherImpl.read
  [ 2] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 3] sun.nio.ch.IOUtil.read
  [ 4] sun.nio.ch.FileChannelImpl.read
  [ 5] io.ktor.util.BufferViewJvmKt.read
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] read
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [10] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [11] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [12] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [13] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [17] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.jvm.internal.Intrinsics.checkNotNull
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
  [ 1] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 2] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.DispatchedTask.run
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListKt.unwrap
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] close
  [ 1] java.io.FileDescriptor.close0
  [ 2] java.io.FileDescriptor.close
  [ 3] java.io.RandomAccessFile$1.close
  [ 4] java.io.FileDescriptor.closeAll
  [ 5] java.io.RandomAccessFile.close
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] java.lang.Integer.intValue
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.<init>
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 2] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 3] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] semaphore_wait_trap
  [ 1] GangWorker::loop()
  [ 2] Thread::call_run()
  [ 3] thread_native_entry(Thread*)
  [ 4] __os_ch_md_redzone_cookie
  [ 5] internal_catch_exc_subsystem

--- 20000000 ns (0.01%), 2 samples
  [ 0] Java_sun_nio_ch_FileDispatcherImpl_read0
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$getState
  [ 2] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 20000000 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] NodeHash::hash_find_insert(Node*)
  [ 1] PhaseGVN::transform_no_reclaim(Node*)
  [ 2] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 3] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 4] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 5] CompileBroker::compiler_thread_loop()
  [ 6] JavaThread::thread_main_inner()
  [ 7] Thread::call_run()
  [ 8] thread_native_entry(Thread*)
  [ 9] __os_ch_md_redzone_cookie
  [10] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_avgt_jmhStub
  [ 1] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_AverageTime
  [ 2] jdk.internal.reflect.NativeMethodAccessorImpl.invoke0
  [ 3] jdk.internal.reflect.NativeMethodAccessorImpl.invoke
  [ 4] jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke
  [ 5] java.lang.reflect.Method.invoke
  [ 6] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [ 7] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] jlong_arraycopy
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.limit
  [ 1] java.nio.ByteBuffer.limit
  [ 2] java.nio.MappedByteBuffer.limit
  [ 3] java.nio.MappedByteBuffer.limit
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] LIR_OpVisitState::visit(LIR_Op*)
  [ 1] LinearScan::build_intervals()
  [ 2] LinearScan::do_linear_scan()
  [ 3] Compilation::emit_lir()
  [ 4] Compilation::compile_java_method()
  [ 5] Compilation::compile_method()
  [ 6] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 7] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 8] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 9] CompileBroker::compiler_thread_loop()
  [10] JavaThread::thread_main_inner()
  [11] Thread::call_run()
  [12] thread_native_entry(Thread*)
  [13] __os_ch_md_redzone_cookie
  [14] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.flush
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] TypeInstPtr::hash() const
  [ 1] Type::hashcons()
  [ 2] TypeOopPtr::make_from_klass_common(ciKlass*, bool, bool)
  [ 3] TypeTuple::make_domain(ciInstanceKlass*, ciSignature*)
  [ 4] TypeFunc::make(ciMethod*)
  [ 5] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 6] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 7] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 8] CompileBroker::compiler_thread_loop()
  [ 9] JavaThread::thread_main_inner()
  [10] Thread::call_run()
  [11] thread_native_entry(Thread*)
  [12] __os_ch_md_redzone_cookie
  [13] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.ByteBuffer.put
  [ 1] java.nio.HeapByteBuffer.put
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.accessCheck
  [ 1] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 2] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] AbstractICache::invalidate_word(unsigned char*)
  [ 1] CodeBuffer::copy_code_to(CodeBlob*)
  [ 2] nmethod::nmethod(Method*, CompilerType, int, int, int, CodeOffsets*, int, DebugInformationRecorder*, Dependencies*, CodeBuffer*, int, OopMapSet*, ExceptionHandlerTable*, ImplicitExceptionTable*, AbstractCompiler*, int, GrowableArrayView<BufferBlob*> const&, char*, int, int)
  [ 3] nmethod::new_nmethod(methodHandle const&, int, int, CodeOffsets*, int, DebugInformationRecorder*, Dependencies*, CodeBuffer*, int, OopMapSet*, ExceptionHandlerTable*, ImplicitExceptionTable*, AbstractCompiler*, int, GrowableArrayView<BufferBlob*> const&, char*, int, int, char const*, FailedSpeculation**)
  [ 4] ciEnv::register_method(ciMethod*, int, CodeOffsets*, int, CodeBuffer*, int, OopMapSet*, ExceptionHandlerTable*, ImplicitExceptionTable*, AbstractCompiler*, bool, bool, RTMState, GrowableArrayView<BufferBlob*> const&)
  [ 5] Compilation::compile_method()
  [ 6] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 7] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 8] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 9] CompileBroker::compiler_thread_loop()
  [10] JavaThread::thread_main_inner()
  [11] Thread::call_run()
  [12] thread_native_entry(Thread*)
  [13] __os_ch_md_redzone_cookie
  [14] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.ReadWriteBufferState$Writing.startReading$ktor_io
  [ 1] io.ktor.utils.io.internal.ReadWriteBufferState$Writing.startReading$ktor_io
  [ 2] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] stat$INODE64
  [ 1] java.io.UnixFileSystem.getLength
  [ 2] java.io.File.length
  [ 3] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 4] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.LinkedBlockingQueue.<init>
  [ 1] java.util.concurrent.LinkedBlockingQueue.<init>
  [ 2] java.util.concurrent.ExecutorCompletionService.<init>
  [ 3] org.openjdk.jmh.runner.BenchmarkHandler.runIteration
  [ 4] org.openjdk.jmh.runner.BaseRunner.runBenchmark
  [ 5] org.openjdk.jmh.runner.BaseRunner.runBenchmark
  [ 6] org.openjdk.jmh.runner.BaseRunner.doSingle
  [ 7] org.openjdk.jmh.runner.BaseRunner.runBenchmarksForked
  [ 8] org.openjdk.jmh.runner.ForkedRunner.run
  [ 9] org.openjdk.jmh.runner.ForkedMain.main

--- 10000000 ns (0.01%), 1 sample
  [ 0] JVM_ReferenceRefersTo
  [ 1] java.lang.ref.Reference.refersTo0
  [ 2] java.lang.ref.Reference.refersTo
  [ 3] java.io.ObjectStreamClass$WeakClassKey.equals
  [ 4] java.util.concurrent.ConcurrentHashMap.get
  [ 5] java.io.ObjectStreamClass.lookup
  [ 6] java.io.ObjectOutputStream.writeObject0
  [ 7] java.io.ObjectOutputStream.writeObject
  [ 8] org.openjdk.jmh.runner.link.BinaryLinkClient.pushFrame
  [ 9] org.openjdk.jmh.runner.link.BinaryLinkClient.access$000
  [10] org.openjdk.jmh.runner.link.BinaryLinkClient$1.invoke
  [11] jdk.proxy1.$Proxy0.iterationResult
  [12] org.openjdk.jmh.runner.BaseRunner.runBenchmark
  [13] org.openjdk.jmh.runner.BaseRunner.runBenchmark
  [14] org.openjdk.jmh.runner.BaseRunner.doSingle
  [15] org.openjdk.jmh.runner.BaseRunner.runBenchmarksForked
  [16] org.openjdk.jmh.runner.ForkedRunner.run
  [17] org.openjdk.jmh.runner.ForkedMain.main

--- 10000000 ns (0.01%), 1 sample
  [ 0] os::elapsed_counter()
  [ 1] CompositeElapsedCounterSource::now()
  [ 2] G1EvacPhaseWithTrimTimeTracker::~G1EvacPhaseWithTrimTimeTracker()
  [ 3] G1ScanCollectionSetRegionClosure::do_heap_region(HeapRegion*)
  [ 4] G1CollectionSet::iterate_part_from(HeapRegionClosure*, HeapRegionClaimer*, unsigned long, unsigned long, unsigned int, unsigned int) const
  [ 5] G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure*, HeapRegionClaimer*, unsigned int, unsigned int) const
  [ 6] G1RemSet::scan_collection_set_regions(G1ParScanThreadState*, unsigned int, G1GCPhaseTimes::GCParPhases, G1GCPhaseTimes::GCParPhases, G1GCPhaseTimes::GCParPhases)
  [ 7] G1EvacuateRegionsBaseTask::work(unsigned int)
  [ 8] GangWorker::loop()
  [ 9] Thread::call_run()
  [10] thread_native_entry(Thread*)
  [11] __os_ch_md_redzone_cookie
  [12] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.getClosed
  [ 1] io.ktor.utils.io.ByteBufferChannel.writeSuspendPredicate
  [ 2] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 3] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.jvm.internal.Intrinsics.areEqual
  [ 1] kotlin.coroutines.CoroutineContext$Element$DefaultImpls.get
  [ 2] kotlinx.coroutines.Job$DefaultImpls.get
  [ 3] kotlinx.coroutines.JobSupport.get
  [ 4] kotlin.coroutines.CombinedContext.get
  [ 5] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 6] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [12] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] sun.nio.ch.NativeThreadSet.add
  [ 1] sun.nio.ch.FileChannelImpl.read
  [ 2] io.ktor.util.BufferViewJvmKt.read
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$flushImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 4] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 5] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 6] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] BacktraceBuilder::push(Method*, int, Thread*)
  [ 1] java_lang_Throwable::fill_in_stack_trace(Handle, methodHandle const&, Thread*)
  [ 2] java_lang_Throwable::fill_in_stack_trace(Handle, methodHandle const&)
  [ 3] JVM_FillInStackTrace
  [ 4] Java_java_lang_Throwable_fillInStackTrace
  [ 5] java.lang.Throwable.fillInStackTrace
  [ 6] java.lang.Throwable.fillInStackTrace
  [ 7] java.lang.Throwable.<init>
  [ 8] java.lang.Exception.<init>
  [ 9] java.lang.RuntimeException.<init>
  [10] java.lang.IllegalStateException.<init>
  [11] java.util.concurrent.CancellationException.<init>
  [12] io.ktor.utils.io.ClosedWriteChannelException.<init>
  [13] io.ktor.utils.io.ByteBufferChannel.close
  [14] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [15] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [16] kotlinx.coroutines.InvokeOnCompletion.invoke
  [17] kotlinx.coroutines.JobSupport.notifyCompletion
  [18] kotlinx.coroutines.JobSupport.completeStateFinalization
  [19] kotlinx.coroutines.JobSupport.finalizeFinishingState
  [20] kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath
  [21] kotlinx.coroutines.JobSupport.tryMakeCompleting
  [22] kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core
  [23] kotlinx.coroutines.AbstractCoroutine.resumeWith
  [24] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [25] kotlinx.coroutines.DispatchedTask.run
  [26] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [27] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal(Node*, Node*, Node*)
  [ 1] PhaseIdealLoop::compute_lca_of_uses(Node*, Node*, bool)
  [ 2] PhaseIdealLoop::get_late_ctrl(Node*, Node*)
  [ 3] PhaseIdealLoop::build_loop_late_post_work(Node*, bool)
  [ 4] PhaseIdealLoop::build_loop_late(VectorSet&, Node_List&, Node_Stack&)
  [ 5] PhaseIdealLoop::build_and_optimize(LoopOptsMode)
  [ 6] PhaseIdealLoop::optimize(PhaseIterGVN&, LoopOptsMode)
  [ 7] Compile::Optimize()
  [ 8] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 9] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [10] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [11] CompileBroker::compiler_thread_loop()
  [12] JavaThread::thread_main_inner()
  [13] Thread::call_run()
  [14] thread_native_entry(Thread*)
  [15] __os_ch_md_redzone_cookie
  [16] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 2] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 3] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 4] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 5] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 6] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 7] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 8] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 9] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] rRegIOper::type() const
  [ 1] PhaseChaitin::gather_lrg_masks(bool)
  [ 2] PhaseCFG::global_code_motion()
  [ 3] PhaseCFG::do_global_code_motion()
  [ 4] Compile::Code_Gen()
  [ 5] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 6] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 7] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 8] CompileBroker::compiler_thread_loop()
  [ 9] JavaThread::thread_main_inner()
  [10] Thread::call_run()
  [11] thread_native_entry(Thread*)
  [12] __os_ch_md_redzone_cookie
  [13] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] os::elapsed_counter()
  [ 1] G1ServiceThread::run_service()
  [ 2] ConcurrentGCThread::run()
  [ 3] Thread::call_run()
  [ 4] thread_native_entry(Thread*)
  [ 5] __os_ch_md_redzone_cookie
  [ 6] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.<init>
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.<init>
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] thread_self_trap
  [ 1] ttyLocker::release_tty_if_locked()
  [ 2] ciEnv::get_klass_by_name_impl(ciKlass*, constantPoolHandle const&, ciSymbol*, bool)
  [ 3] ciEnv::get_klass_by_index_impl(constantPoolHandle const&, int, bool&, ciInstanceKlass*)
  [ 4] ciField::ciField(ciInstanceKlass*, int)
  [ 5] ciEnv::get_field_by_index_impl(ciInstanceKlass*, int)
  [ 6] ciEnv::get_field_by_index(ciInstanceKlass*, int)
  [ 7] ciBytecodeStream::get_field(bool&)
  [ 8] GraphBuilder::access_field(Bytecodes::Code)
  [ 9] GraphBuilder::iterate_bytecodes_for_block(int)
  [10] GraphBuilder::iterate_all_blocks(bool)
  [11] GraphBuilder::try_inline_full(ciMethod*, bool, bool, Bytecodes::Code, Instruction*)
  [12] GraphBuilder::try_inline(ciMethod*, bool, bool, Bytecodes::Code, Instruction*)
  [13] GraphBuilder::invoke(Bytecodes::Code)
  [14] GraphBuilder::iterate_bytecodes_for_block(int)
  [15] GraphBuilder::iterate_all_blocks(bool)
  [16] GraphBuilder::GraphBuilder(Compilation*, IRScope*)
  [17] IRScope::IRScope(Compilation*, IRScope*, int, ciMethod*, int, bool)
  [18] IR::IR(Compilation*, ciMethod*, int)
  [19] Compilation::build_hir()
  [20] Compilation::compile_java_method()
  [21] Compilation::compile_method()
  [22] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [23] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [24] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [25] CompileBroker::compiler_thread_loop()
  [26] JavaThread::thread_main_inner()
  [27] Thread::call_run()
  [28] thread_native_entry(Thread*)
  [29] __os_ch_md_redzone_cookie
  [30] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] void G1ParScanThreadState::do_oop_evac<narrowOop>(narrowOop*)
  [ 1] G1ParScanThreadState::trim_queue_to_threshold(unsigned int)
  [ 2] G1ParEvacuateFollowersClosure::do_void()
  [ 3] G1EvacuateRegionsBaseTask::evacuate_live_objects(G1ParScanThreadState*, unsigned int, G1GCPhaseTimes::GCParPhases, G1GCPhaseTimes::GCParPhases)
  [ 4] G1EvacuateRegionsBaseTask::work(unsigned int)
  [ 5] GangWorker::loop()
  [ 6] Thread::call_run()
  [ 7] thread_native_entry(Thread*)
  [ 8] __os_ch_md_redzone_cookie
  [ 9] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.CoroutineScopeKt.CoroutineScope
  [ 1] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 2] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 1] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] SharedRuntime::java_calling_convention(BasicType const*, VMRegPair*, int)
  [ 1] Compile::Code_Gen()
  [ 2] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 3] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 4] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 5] CompileBroker::compiler_thread_loop()
  [ 6] JavaThread::thread_main_inner()
  [ 7] Thread::call_run()
  [ 8] thread_native_entry(Thread*)
  [ 9] __os_ch_md_redzone_cookie
  [10] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] GraphKit::round_double_result(ciMethod*)
  [ 1] Parse::do_call()
  [ 2] Parse::do_one_block()
  [ 3] Parse::do_all_blocks()
  [ 4] Parse::Parse(JVMState*, ciMethod*, float)
  [ 5] ParseGenerator::generate(JVMState*)
  [ 6] Compile::Compile(ciEnv*, ciMethod*, int, bool, bool, bool, bool, DirectiveSet*)
  [ 7] C2Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 8] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 9] CompileBroker::compiler_thread_loop()
  [10] JavaThread::thread_main_inner()
  [11] Thread::call_run()
  [12] thread_native_entry(Thread*)
  [13] __os_ch_md_redzone_cookie
  [14] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] err_codes_iokit_usb
  [ 1] WatcherThread::run()
  [ 2] Thread::call_run()
  [ 3] thread_native_entry(Thread*)
  [ 4] __os_ch_md_redzone_cookie
  [ 5] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 4] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.ContinuationInterceptor$DefaultImpls.get
  [ 1] kotlinx.coroutines.CoroutineDispatcher.get
  [ 2] kotlin.coroutines.CombinedContext.get
  [ 3] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 4] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 5] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.JobSupport.fold
  [ 1] kotlin.coroutines.CoroutineContext$DefaultImpls.plus
  [ 2] kotlin.coroutines.CoroutineContext$Element$DefaultImpls.plus
  [ 3] kotlin.coroutines.AbstractCoroutineContextElement.plus
  [ 4] kotlinx.coroutines.CoroutineScopeKt.CoroutineScope
  [ 5] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 6] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.AtomicOp.perform
  [ 1] kotlinx.coroutines.internal.LockFreeLinkedListNode.tryCondAddNext
  [ 2] kotlinx.coroutines.JobSupport.addLastAtomic
  [ 3] kotlinx.coroutines.JobSupport.invokeOnCompletion
  [ 4] kotlinx.coroutines.Job$DefaultImpls.invokeOnCompletion$default
  [ 5] io.ktor.utils.io.ByteBufferChannel.attachJob
  [ 6] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] sort_pairs(BlockPair**, BlockPair**)
  [ 1] [unknown]
  [ 2] IR::split_critical_edges()
  [ 3] Compilation::build_hir()
  [ 4] Compilation::compile_java_method()
  [ 5] Compilation::compile_method()
  [ 6] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 7] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 8] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 9] CompileBroker::compiler_thread_loop()
  [10] JavaThread::thread_main_inner()
  [11] Thread::call_run()
  [12] thread_native_entry(Thread*)
  [13] __os_ch_md_redzone_cookie
  [14] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] I2C/C2I adapters
  [ 1] kotlinx.coroutines.BuildersKt.launch$default
  [ 2] io.ktor.utils.io.CoroutinesKt.launchChannel
  [ 3] io.ktor.utils.io.CoroutinesKt.writer
  [ 4] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 5] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] sun.nio.ch.NativeThreadSet.add
  [ 1] sun.nio.ch.FileChannelImpl.read
  [ 2] io.ktor.util.BufferViewJvmKt.read
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] AbstractInterpreter::deopt_continue_after_entry(Method*, unsigned char*, int, bool)
  [ 1] vframeArrayElement::unpack_on_stack(int, int, int, frame*, bool, bool, int)
  [ 2] vframeArray::unpack_to_stack(frame&, int, int)
  [ 3] Deoptimization::unpack_frames(JavaThread*, int)
  [ 4] [deoptimization]

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.getPrev
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.addLast
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.ByteBuffer.position
  [ 1] java.nio.MappedByteBuffer.position
  [ 2] java.nio.MappedByteBuffer.position
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
  [ 1] io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
  [ 2] io.ktor.util.internal.LockFreeLinkedListNode.remove
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] fdval
  [ 1] Java_sun_nio_ch_FileDispatcherImpl_read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read0
  [ 3] sun.nio.ch.FileDispatcherImpl.read
  [ 4] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 5] sun.nio.ch.IOUtil.read
  [ 6] sun.nio.ch.FileChannelImpl.read
  [ 7] io.ktor.util.BufferViewJvmKt.read
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.channels.spi.AbstractInterruptibleChannel.isOpen
  [ 1] sun.nio.ch.FileChannelImpl.ensureOpen
  [ 2] sun.nio.ch.FileChannelImpl.read
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] JVM_ReferenceRefersTo
  [ 1] java.lang.ref.Reference.refersTo0
  [ 2] java.lang.ref.Reference.refersTo
  [ 3] java.lang.ThreadLocal$ThreadLocalMap.getEntry
  [ 4] java.lang.ThreadLocal.get
  [ 5] kotlinx.coroutines.ThreadLocalEventLoop.currentOrNull$kotlinx_coroutines_core
  [ 6] kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking
  [ 7] kotlinx.coroutines.BuildersKt.runBlocking
  [ 8] io.ktor.benchmarks.FileBenchmarks.testKtorFileReadInIo2IoDispatcher
  [ 9] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_avgt_jmhStub
  [10] io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_AverageTime
  [11] jdk.internal.reflect.NativeMethodAccessorImpl.invoke0
  [12] jdk.internal.reflect.NativeMethodAccessorImpl.invoke
  [13] jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke
  [14] java.lang.reflect.Method.invoke
  [15] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [16] org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call
  [17] java.util.concurrent.FutureTask.run
  [18] java.util.concurrent.Executors$RunnableAdapter.call
  [19] java.util.concurrent.FutureTask.run
  [20] java.util.concurrent.ThreadPoolExecutor.runWorker
  [21] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [22] java.lang.Thread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] NullCheckEliminator::iterate_one(BlockBegin*)
  [ 1] Optimizer::eliminate_null_checks()
  [ 2] IR::eliminate_null_checks()
  [ 3] Compilation::build_hir()
  [ 4] Compilation::compile_java_method()
  [ 5] Compilation::compile_method()
  [ 6] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 7] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [ 8] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [ 9] CompileBroker::compiler_thread_loop()
  [10] JavaThread::thread_main_inner()
  [11] Thread::call_run()
  [12] thread_native_entry(Thread*)
  [13] __os_ch_md_redzone_cookie
  [14] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] OptoRuntime::new_instance_C(Klass*, JavaThread*)
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.LockFreeLinkedListNode.isRemoved
  [ 1] kotlinx.coroutines.internal.LockFreeLinkedListNode.finishAdd
  [ 2] kotlinx.coroutines.internal.LockFreeLinkedListNode.access$finishAdd
  [ 3] kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp.complete
  [ 4] kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp.complete
  [ 5] kotlinx.coroutines.internal.AtomicOp.perform
  [ 6] kotlinx.coroutines.internal.LockFreeLinkedListNode.tryCondAddNext
  [ 7] kotlinx.coroutines.JobSupport.addLastAtomic
  [ 8] kotlinx.coroutines.JobSupport.invokeOnCompletion
  [ 9] kotlinx.coroutines.Job$DefaultImpls.invokeOnCompletion$default
  [10] io.ktor.utils.io.ByteBufferChannel.attachJob
  [11] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
  [ 1] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.getAndSet
  [ 2] io.ktor.utils.io.internal.CancellableReusableContinuation.close
  [ 3] io.ktor.utils.io.ByteBufferChannel.close
  [ 4] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [ 5] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [ 6] kotlinx.coroutines.InvokeOnCompletion.invoke
  [ 7] kotlinx.coroutines.JobSupport.notifyCompletion
  [ 8] kotlinx.coroutines.JobSupport.completeStateFinalization
  [ 9] kotlinx.coroutines.JobSupport.finalizeFinishingState
  [10] kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath
  [11] kotlinx.coroutines.JobSupport.tryMakeCompleting
  [12] kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core
  [13] kotlinx.coroutines.AbstractCoroutine.resumeWith
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [17] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlin.ResultKt.throwOnFailure
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.awaitReusability
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.release
  [ 2] kotlinx.coroutines.CoroutineDispatcher.releaseInterceptedContinuation
  [ 3] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] MoveResolver::resolve_mappings()
  [ 1] LinearScanWalker::insert_move(int, Interval*, Interval*)
  [ 2] LinearScanWalker::activate_current()
  [ 3] IntervalWalker::walk_to(int)
  [ 4] LinearScan::allocate_registers()
  [ 5] LinearScan::do_linear_scan()
  [ 6] Compilation::emit_lir()
  [ 7] Compilation::compile_java_method()
  [ 8] Compilation::compile_method()
  [ 9] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [10] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [11] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [12] CompileBroker::compiler_thread_loop()
  [13] JavaThread::thread_main_inner()
  [14] Thread::call_run()
  [15] thread_native_entry(Thread*)
  [16] __os_ch_md_redzone_cookie
  [17] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] LinearScanWalker::alloc_free_reg(Interval*)
  [ 1] LinearScanWalker::activate_current()
  [ 2] IntervalWalker::walk_to(int)
  [ 3] LinearScan::allocate_registers()
  [ 4] LinearScan::do_linear_scan()
  [ 5] Compilation::emit_lir()
  [ 6] Compilation::compile_java_method()
  [ 7] Compilation::compile_method()
  [ 8] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [ 9] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [10] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [11] CompileBroker::compiler_thread_loop()
  [12] JavaThread::thread_main_inner()
  [13] Thread::call_run()
  [14] thread_native_entry(Thread*)
  [15] __os_ch_md_redzone_cookie
  [16] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.clear
  [ 1] java.nio.ByteBuffer.clear
  [ 2] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] ObjAllocator::initialize(HeapWordImpl**) const
  [ 1] InstanceKlass::allocate_instance(Thread*)
  [ 2] OptoRuntime::new_instance_C(Klass*, JavaThread*)
  [ 3] java.nio.DirectByteBuffer.duplicate
  [ 4] io.ktor.util.BufferViewJvmKt.read
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$getState
  [ 2] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.ByteBuffer.put
  [ 1] java.nio.HeapByteBuffer.put
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.BuildersKt__Builders_commonKt.launch$default
  [ 1] kotlinx.coroutines.BuildersKt.launch$default
  [ 2] io.ktor.utils.io.CoroutinesKt.launchChannel
  [ 3] io.ktor.utils.io.CoroutinesKt.writer
  [ 4] io.ktor.util.cio.FileChannelsKt.readChannel
  [ 5] io.ktor.util.cio.FileChannelsKt.readChannel$default
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] [unknown]
  [ 1] AllocTracer::send_allocation_in_new_tlab(Klass*, HeapWordImpl**, unsigned long, unsigned long, Thread*)
  [ 2] MemAllocator::Allocation::notify_allocation()
  [ 3] MemAllocator::allocate() const
  [ 4] InstanceKlass::allocate_instance(Thread*)
  [ 5] OptoRuntime::new_instance_C(Klass*, JavaThread*)
  [ 6] java.nio.DirectByteBuffer.duplicate
  [ 7] io.ktor.util.BufferViewJvmKt.read
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.core.IoBuffer.<init>
  [ 1] io.ktor.utils.io.core.IoBuffer.<init>
  [ 2] io.ktor.utils.io.core.IoBuffer.<init>
  [ 3] io.ktor.utils.io.core.IoBuffer.<init>
  [ 4] io.ktor.utils.io.core.IoBuffer.<init>
  [ 5] io.ktor.utils.io.internal.WriteSessionImpl.begin
  [ 6] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [ 9] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [10] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [11] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] unsafe_arraycopy
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.scope
  [ 1] java.nio.Buffer.checkScope
  [ 2] java.nio.HeapByteBuffer.put
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] java.nio.Buffer.limit
  [ 1] java.nio.ByteBuffer.limit
  [ 2] java.nio.MappedByteBuffer.limit
  [ 3] java.nio.MappedByteBuffer.limit
  [ 4] io.ktor.utils.io.ByteBufferChannel.prepareBuffer
  [ 5] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [16] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.getReusableCancellableContinuation
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.release
  [ 2] kotlinx.coroutines.CoroutineDispatcher.releaseInterceptedContinuation
  [ 3] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.getReadByteOrder
  [ 1] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [12] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] G1BlockOffsetTablePart::forward_to_block_containing_addr_slow(HeapWordImpl**, HeapWordImpl**, void const*)
  [ 1] HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<true, G1ScanCardClosure>(MemRegion, G1ScanCardClosure*)
  [ 2] G1ScanHRForRegionClosure::scan_memregion(unsigned int, MemRegion)
  [ 3] G1ScanHRForRegionClosure::scan_heap_roots(HeapRegion*)
  [ 4] G1ScanHRForRegionClosure::do_heap_region(HeapRegion*)
  [ 5] G1RemSet::scan_heap_roots(G1ParScanThreadState*, unsigned int, G1GCPhaseTimes::GCParPhases, G1GCPhaseTimes::GCParPhases, bool)
  [ 6] G1EvacuateRegionsTask::scan_roots(G1ParScanThreadState*, unsigned int)
  [ 7] G1EvacuateRegionsBaseTask::work(unsigned int)
  [ 8] GangWorker::loop()
  [ 9] Thread::call_run()
  [10] thread_native_entry(Thread*)
  [11] __os_ch_md_redzone_cookie
  [12] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [11] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] InstanceKlass::find_method_index(Array<Method*> const*, Symbol const*, Symbol const*, Klass::OverpassLookupMode, Klass::StaticLookupMode, Klass::PrivateLookupMode)
  [ 1] InstanceKlass::uncached_lookup_method(Symbol const*, Symbol const*, Klass::OverpassLookupMode, Klass::PrivateLookupMode) const
  [ 2] LinkResolver::resolve_method(LinkInfo const&, Bytecodes::Code, Thread*)
  [ 3] LinkResolver::linktime_resolve_virtual_method(LinkInfo const&, Thread*)
  [ 4] LinkResolver::linktime_resolve_virtual_method_or_null(LinkInfo const&)
  [ 5] ciEnv::lookup_method(ciInstanceKlass*, ciKlass*, Symbol*, Symbol*, Bytecodes::Code, constantTag)
  [ 6] ciEnv::get_method_by_index_impl(constantPoolHandle const&, int, Bytecodes::Code, ciInstanceKlass*)
  [ 7] ciBytecodeStream::get_method(bool&, ciSignature**)
  [ 8] GraphBuilder::invoke(Bytecodes::Code)
  [ 9] GraphBuilder::iterate_bytecodes_for_block(int)
  [10] GraphBuilder::iterate_all_blocks(bool)
  [11] GraphBuilder::GraphBuilder(Compilation*, IRScope*)
  [12] IRScope::IRScope(Compilation*, IRScope*, int, ciMethod*, int, bool)
  [13] IR::IR(Compilation*, ciMethod*, int)
  [14] Compilation::build_hir()
  [15] Compilation::compile_java_method()
  [16] Compilation::compile_method()
  [17] Compilation::Compilation(AbstractCompiler*, ciEnv*, ciMethod*, int, BufferBlob*, bool, DirectiveSet*)
  [18] Compiler::compile_method(ciEnv*, ciMethod*, int, bool, DirectiveSet*)
  [19] CompileBroker::invoke_compiler_on_method(CompileTask*)
  [20] CompileBroker::compiler_thread_loop()
  [21] JavaThread::thread_main_inner()
  [22] Thread::call_run()
  [23] thread_native_entry(Thread*)
  [24] __os_ch_md_redzone_cookie
  [25] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 9] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] void OopOopIterateBoundedDispatch<G1ScanCardClosure>::Table::oop_oop_iterate_bounded<ObjArrayKlass, narrowOop>(G1ScanCardClosure*, oopDesc*, Klass*, MemRegion)
  [ 1] HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<true, G1ScanCardClosure>(MemRegion, G1ScanCardClosure*)
  [ 2] G1ScanHRForRegionClosure::scan_memregion(unsigned int, MemRegion)
  [ 3] G1ScanHRForRegionClosure::scan_heap_roots(HeapRegion*)
  [ 4] G1ScanHRForRegionClosure::do_heap_region(HeapRegion*)
  [ 5] G1RemSet::scan_heap_roots(G1ParScanThreadState*, unsigned int, G1GCPhaseTimes::GCParPhases, G1GCPhaseTimes::GCParPhases, bool)
  [ 6] G1EvacuateRegionsTask::scan_roots(G1ParScanThreadState*, unsigned int)
  [ 7] G1EvacuateRegionsBaseTask::work(unsigned int)
  [ 8] GangWorker::loop()
  [ 9] Thread::call_run()
  [10] thread_native_entry(Thread*)
  [11] __os_ch_md_redzone_cookie
  [12] internal_catch_exc_subsystem

--- 10000000 ns (0.01%), 1 sample
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 4] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.DispatchedTask.run
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 2] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 10000000 ns (0.01%), 1 sample
  [ 0] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 1] sun.nio.ch.IOUtil.read
  [ 2] sun.nio.ch.FileChannelImpl.read
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
  [ 8] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

          ns  percent  samples  top
  ----------  -------  -------  ---
 73050000000   41.00%     7305  io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run
 62460000000   35.05%     6246  java.util.concurrent.ConcurrentLinkedQueue.poll
 15980000000    8.97%     1598  io.ktor.benchmarks.dispatchers.SimpleDispatcher.getQueue
 10380000000    5.83%     1038  io.ktor.benchmarks.dispatchers.SimpleDispatcher.thread$lambda-0
  5270000000    2.96%      527  jlong_disjoint_arraycopy
  1270000000    0.71%      127  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  1260000000    0.71%      126  kotlin.coroutines.jvm.internal.Boxing.boxBoolean
  1110000000    0.62%      111  read
   630000000    0.35%       63  io.ktor.util.internal.LockFreeLinkedListNode.<init>
   560000000    0.31%       56  io.ktor.utils.io.ByteBufferChannel.setupStateForRead
   540000000    0.30%       54  io.ktor.util.internal.LockFreeLinkedListNode.getNext
   390000000    0.22%       39  io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
   360000000    0.20%       36  io.ktor.utils.io.ByteBufferChannel.suspensionForSize
   320000000    0.18%       32  java.nio.ByteBuffer.putBuffer
   300000000    0.17%       30  itable stub
   280000000    0.16%       28  kotlinx.coroutines.JobSupport.getKey
   280000000    0.16%       28  java.nio.ByteBuffer.put
   270000000    0.15%       27  kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
   200000000    0.11%       20  io.ktor.utils.io.ByteBufferChannel.bytesRead
   150000000    0.08%       15  io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
   130000000    0.07%       13  io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
   130000000    0.07%       13  kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
   100000000    0.06%       10  io.ktor.util.internal.LockFreeLinkedListNode.remove
   100000000    0.06%       10  kotlin.jvm.internal.Intrinsics.checkNotNullParameter
    90000000    0.05%        9  __psynch_cvwait
    90000000    0.05%        9  io.ktor.util.internal.LockFreeLinkedListNode.correctPrev
    90000000    0.05%        9  io.ktor.utils.io.ByteBufferChannel.resumeReadOp
    80000000    0.04%        8  kotlin.coroutines.jvm.internal.BaseContinuationImpl.<init>
    80000000    0.04%        8  io.ktor.utils.io.ByteBufferChannel.prepareBuffer
    70000000    0.04%        7  io.ktor.utils.io.ByteBufferChannel.getState
    70000000    0.04%        7  kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
    60000000    0.03%        6  io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.run
    50000000    0.03%        5  java.nio.Buffer.limit
    50000000    0.03%        5  kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
    50000000    0.03%        5  io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInIo2IoDispatcher$1.invokeSuspend
    40000000    0.02%        4  io.ktor.utils.io.core.Buffer.getLimit
    40000000    0.02%        4  io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
    40000000    0.02%        4  sun.nio.ch.NativeThread.current
    30000000    0.02%        3  sun.nio.ch.FileChannelImpl.read
    30000000    0.02%        3  __open
    30000000    0.02%        3  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
    30000000    0.02%        3  io.ktor.util.internal.LockFreeLinkedListNode.finishRemove
    30000000    0.02%        3  jdk.internal.misc.Unsafe.copyMemoryChecks
    30000000    0.02%        3  kotlin.ResultKt.throwOnFailure
    30000000    0.02%        3  kotlin.coroutines.CombinedContext.get
    30000000    0.02%        3  java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
    30000000    0.02%        3  io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
    30000000    0.02%        3  kotlin.jvm.internal.Intrinsics.checkNotNull
    30000000    0.02%        3  kotlinx.coroutines.DispatchedTask.run
    30000000    0.02%        3  io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher.dispatch
    30000000    0.02%        3  semaphore_wait_trap
    30000000    0.02%        3  sun.nio.ch.NativeThreadSet.add
    30000000    0.02%        3  kotlinx.coroutines.internal.DispatchedContinuation.getContext
    30000000    0.02%        3  io.ktor.utils.io.ByteBufferChannel.readSuspend
    20000000    0.01%        2  io.ktor.util.internal.LockFreeLinkedListKt.unwrap
    20000000    0.01%        2  java.lang.Integer.intValue
    20000000    0.01%        2  java.nio.HeapByteBuffer.put
    20000000    0.01%        2  java.nio.channels.spi.AbstractInterruptibleChannel.begin
    20000000    0.01%        2  close
    20000000    0.01%        2  io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
    20000000    0.01%        2  io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
    20000000    0.01%        2  java.nio.channels.spi.AbstractInterruptibleChannel.isOpen
    20000000    0.01%        2  vtable stub
    20000000    0.01%        2  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.lazySet
    20000000    0.01%        2  [unknown]
    20000000    0.01%        2  jdk.internal.misc.Unsafe.copyMemory
    20000000    0.01%        2  kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
    20000000    0.01%        2  kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
    20000000    0.01%        2  Java_sun_nio_ch_FileDispatcherImpl_read0
    20000000    0.01%        2  JVM_ReferenceRefersTo
    20000000    0.01%        2  kotlinx.coroutines.internal.DispatchedContinuation.getReusableCancellableContinuation
    20000000    0.01%        2  Interpreter
    20000000    0.01%        2  os::elapsed_counter()
    20000000    0.01%        2  sun.nio.ch.FileDispatcherImpl.read0
    20000000    0.01%        2  java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.accessCheck
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.isClosedForRead
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.getReadByteOrder
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.getClosed
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.flushImpl
    10000000    0.01%        1  AbstractICache::invalidate_word(unsigned char*)
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
    10000000    0.01%        1  io.ktor.utils.io.core.ByteOrder.getNioOrder
    10000000    0.01%        1  io.ktor.utils.io.core.IoBuffer.<init>
    10000000    0.01%        1  io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
    10000000    0.01%        1  io.ktor.utils.io.internal.ReadWriteBufferState$Writing.startReading$ktor_io
    10000000    0.01%        1  io.ktor.util.internal.LockFreeLinkedListNode.helpDelete
    10000000    0.01%        1  io.ktor.util.internal.LockFreeLinkedListNode.getPrev
    10000000    0.01%        1  io.ktor.util.internal.LockFreeLinkedListNode.addLast
    10000000    0.01%        1  java.lang.Class.cast
    10000000    0.01%        1  io.ktor.benchmarks.jmh_generated.FileBenchmarks_testKtorFileReadInIo2IoDispatcher_jmhTest.testKtorFileReadInIo2IoDispatcher_avgt_jmhStub
    10000000    0.01%        1  java.lang.Thread.blockedOn
    10000000    0.01%        1  java.nio.Buffer.clear
    10000000    0.01%        1  java.nio.Buffer.hasRemaining
    10000000    0.01%        1  io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IODispatchedTask.<init>
    10000000    0.01%        1  java.nio.Buffer.scope
    10000000    0.01%        1  java.nio.ByteBuffer.position
    10000000    0.01%        1  io.ktor.benchmarks.FileBenchmarks.access$getBuffer$p
    10000000    0.01%        1  fdval
    10000000    0.01%        1  err_codes_iokit_usb
    10000000    0.01%        1  compN_rReg_imm_klassNode::emit(CodeBuffer&, PhaseRegAlloc*) const
    10000000    0.01%        1  ciMethodData::load_data()
    10000000    0.01%        1  ciInstanceKlass::ciInstanceKlass(Klass*)
    10000000    0.01%        1  java.util.concurrent.CountDownLatch$Sync.tryAcquireShared
    10000000    0.01%        1  java.util.concurrent.LinkedBlockingQueue.<init>
    10000000    0.01%        1  ciEnv::is_in_vm()
    10000000    0.01%        1  _kernelrpc_mach_port_deallocate_trap
    10000000    0.01%        1  __psynch_mutexdrop
    10000000    0.01%        1  __os_ch_md_redzone_cookie
    10000000    0.01%        1  __gettimeofday
    10000000    0.01%        1  java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
    10000000    0.01%        1  jdk.internal.misc.ScopedMemoryAccess.copyMemory
    10000000    0.01%        1  jdk.internal.misc.Unsafe.checkPointer
    10000000    0.01%        1  ValueStack::ValueStack(ValueStack*, ValueStack::Kind, int)
    10000000    0.01%        1  TypeInstPtr::hash() const
    10000000    0.01%        1  jlong_arraycopy
    10000000    0.01%        1  SharedRuntime::java_calling_convention(BasicType const*, VMRegPair*, int)
    10000000    0.01%        1  ScopeDesc::decode_body()
    10000000    0.01%        1  ResourceObj::operator new(unsigned long, Arena*)
    10000000    0.01%        1  kotlin.coroutines.ContinuationInterceptor$DefaultImpls.get
    10000000    0.01%        1  PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal(Node*, Node*, Node*)
    10000000    0.01%        1  OptoRuntime::new_instance_C(Klass*, JavaThread*)
    10000000    0.01%        1  ObjAllocator::initialize(HeapWordImpl**) const
    10000000    0.01%        1  NullCheckEliminator::iterate_one(BlockBegin*)
    10000000    0.01%        1  NodeHash::hash_find_insert(Node*)
    10000000    0.01%        1  kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
    10000000    0.01%        1  MoveResolver::resolve_mappings()
    10000000    0.01%        1  kotlin.jvm.internal.Intrinsics.areEqual
    10000000    0.01%        1  LoadKlassNode::make(PhaseGVN&, Node*, Node*, Node*, TypePtr const*, TypeKlassPtr const*)
    10000000    0.01%        1  LinearScanWalker::alloc_free_reg(Interval*)
    10000000    0.01%        1  kotlinx.coroutines.BuildersKt.launch$default
    10000000    0.01%        1  kotlinx.coroutines.BuildersKt__Builders_commonKt.launch$default
    10000000    0.01%        1  kotlinx.coroutines.CoroutineScopeKt.CoroutineScope
    10000000    0.01%        1  LIR_OpVisitState::visit(LIR_Op*)
    10000000    0.01%        1  kotlinx.coroutines.JobSupport.fold
    10000000    0.01%        1  LIR_List::metadata2reg(Metadata*, LIR_OprDesc*)
    10000000    0.01%        1  kotlinx.coroutines.internal.AtomicOp.perform
    10000000    0.01%        1  kotlinx.coroutines.internal.DispatchedContinuation.awaitReusability
    10000000    0.01%        1  LIR_Assembler::logic_op(LIR_Code, LIR_OprDesc*, LIR_OprDesc*, LIR_OprDesc*)
    10000000    0.01%        1  IntervalWalker::walk_to(IntervalState, int)
    10000000    0.01%        1  InstanceKlass::find_method_index(Array<Method*> const*, Symbol const*, Symbol const*, Klass::OverpassLookupMode, Klass::StaticLookupMode, Klass::PrivateLookupMode)
    10000000    0.01%        1  kotlinx.coroutines.internal.LockFreeLinkedListNode.isRemoved
    10000000    0.01%        1  kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
    10000000    0.01%        1  I2C/C2I adapters
    10000000    0.01%        1  GraphKit::round_double_result(ciMethod*)
    10000000    0.01%        1  rRegIOper::type() const
    10000000    0.01%        1  G1ParScanThreadState::do_copy_to_survivor_space(G1HeapRegionAttr, oopDesc*, markWord)
    10000000    0.01%        1  G1CollectionSet::update_young_region_prediction(HeapRegion*, unsigned long)
    10000000    0.01%        1  sort_pairs(BlockPair**, BlockPair**)
    10000000    0.01%        1  stat$INODE64
    10000000    0.01%        1  G1CodeRootSet::contains(nmethod*)
    10000000    0.01%        1  G1BlockOffsetTablePart::forward_to_block_containing_addr_slow(HeapWordImpl**, HeapWordImpl**, void const*)
    10000000    0.01%        1  sun.nio.ch.IOUtil.readIntoNativeBuffer
    10000000    0.01%        1  BacktraceBuilder::push(Method*, int, Thread*)
    10000000    0.01%        1  AbstractInterpreter::deopt_continue_after_entry(Method*, unsigned char*, int, bool)
    10000000    0.01%        1  thread_self_trap
    10000000    0.01%        1  unsafe_arraycopy
    10000000    0.01%        1  void G1ParScanThreadState::do_oop_evac<narrowOop>(narrowOop*)
    10000000    0.01%        1  void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>(narrowOop*)
    10000000    0.01%        1  void OopOopIterateBoundedDispatch<G1ScanCardClosure>::Table::oop_oop_iterate_bounded<ObjArrayKlass, narrowOop>(G1ScanCardClosure*, oopDesc*, Klass*, MemRegion)
    10000000    0.01%        1  io.ktor.utils.io.ByteBufferChannel.writeSuspendPredicate

