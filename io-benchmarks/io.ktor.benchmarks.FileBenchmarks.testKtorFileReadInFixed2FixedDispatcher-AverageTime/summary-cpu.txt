--- Execution profile ---
Total samples       : 23280
unknown_Java        : 37 (0.16%)

--- 84983354735 ns (33.44%), 8494 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 39821710853 ns (15.67%), 3981 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 3] java.lang.Thread.run

--- 25480839175 ns (10.03%), 2548 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 3] java.lang.Thread.run

--- 20560558017 ns (8.09%), 2056 samples
  [ 0] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.getQueue
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 3] java.lang.Thread.run

--- 13638798089 ns (5.37%), 846 samples
  [ 0] __GI___pthread_mutex_unlock
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 8910439876 ns (3.51%), 890 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 7230387622 ns (2.85%), 722 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 3] java.lang.Thread.run

--- 7210315092 ns (2.84%), 721 samples
  [ 0] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 2] java.lang.Thread.run

--- 4320152460 ns (1.70%), 432 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 3990091903 ns (1.57%), 399 samples
  [ 0] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 3550090796 ns (1.40%), 214 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 3128602104 ns (1.23%), 146 samples
  [ 0] __pthread_cond_signal
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [20] kotlinx.coroutines.DispatchedTask.run
  [21] java.util.concurrent.Executors$RunnableAdapter.call
  [22] java.util.concurrent.FutureTask.run
  [23] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [24] java.util.concurrent.ThreadPoolExecutor.runWorker
  [25] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [26] java.lang.Thread.run

--- 2540976247 ns (1.00%), 117 samples
  [ 0] read
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 1940666959 ns (0.76%), 124 samples
  [ 0] __pthread_cond_signal
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [15] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [16] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [17] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [19] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [20] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [21] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [22] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [23] kotlinx.coroutines.DispatchedTask.run
  [24] java.util.concurrent.Executors$RunnableAdapter.call
  [25] java.util.concurrent.FutureTask.run
  [26] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [27] java.util.concurrent.ThreadPoolExecutor.runWorker
  [28] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [29] java.lang.Thread.run

--- 1542242171 ns (0.61%), 109 samples
  [ 0] jlong_disjoint_arraycopy
  [ 1] java.nio.MappedByteBuffer.limit
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 1050067648 ns (0.41%), 105 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 3] java.lang.Thread.run

--- 808451672 ns (0.32%), 47 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 1] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 2] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 5] java.util.concurrent.locks.ReentrantLock.lock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [20] kotlinx.coroutines.DispatchedTask.run
  [21] java.util.concurrent.Executors$RunnableAdapter.call
  [22] java.util.concurrent.FutureTask.run
  [23] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [24] java.util.concurrent.ThreadPoolExecutor.runWorker
  [25] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [26] java.lang.Thread.run

--- 780774360 ns (0.31%), 51 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 3] jdk.internal.misc.Unsafe.park
  [ 4] java.util.concurrent.locks.LockSupport.park
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 8] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 777874744 ns (0.31%), 35 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [16] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [17] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [18] io.ktor.utils.io.ByteBufferChannel.flush
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [20] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [21] kotlinx.coroutines.DispatchedTask.run
  [22] java.util.concurrent.Executors$RunnableAdapter.call
  [23] java.util.concurrent.FutureTask.run
  [24] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [25] java.util.concurrent.ThreadPoolExecutor.runWorker
  [26] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [27] java.lang.Thread.run

--- 710146156 ns (0.28%), 71 samples
  [ 0] java.util.concurrent.ConcurrentLinkedQueue.poll
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 2] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 3] java.lang.Thread.run

--- 684645789 ns (0.27%), 35 samples
  [ 0] __tls_get_addr
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 3] jdk.internal.misc.Unsafe.park
  [ 4] java.util.concurrent.locks.LockSupport.park
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 8] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 635469330 ns (0.25%), 26 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [20] kotlinx.coroutines.DispatchedTask.run
  [21] java.util.concurrent.Executors$RunnableAdapter.call
  [22] java.util.concurrent.FutureTask.run
  [23] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [24] java.util.concurrent.ThreadPoolExecutor.runWorker
  [25] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [26] java.lang.Thread.run

--- 594824553 ns (0.23%), 28 samples
  [ 0] [vdso]
  [ 1] clock_gettime
  [ 2] [unknown_Java]

--- 552752549 ns (0.22%), 31 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.findNodeFromTail
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 511457776 ns (0.20%), 28 samples
  [ 0] java.lang.invoke.VarHandleInts$FieldInstanceReadWrite.compareAndSet
  [ 1] java.lang.invoke.VarHandleGuards.guard_LII_Z
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 3] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 4] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
  [ 6] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 9] java.util.concurrent.ThreadPoolExecutor.getTask
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 484624469 ns (0.19%), 13 samples
  [ 0] read
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 9] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [10] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [12] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [13] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [14] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [15] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [16] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [17] kotlinx.coroutines.DispatchedTask.run
  [18] java.util.concurrent.Executors$RunnableAdapter.call
  [19] java.util.concurrent.FutureTask.run
  [20] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [21] java.util.concurrent.ThreadPoolExecutor.runWorker
  [22] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [23] java.lang.Thread.run

--- 441256751 ns (0.17%), 31 samples
  [ 0] java.lang.Thread.interrupted
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 393131127 ns (0.15%), 23 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [16] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [17] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [19] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [20] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [21] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [22] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [23] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [24] kotlinx.coroutines.DispatchedTask.run
  [25] java.util.concurrent.Executors$RunnableAdapter.call
  [26] java.util.concurrent.FutureTask.run
  [27] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [28] java.util.concurrent.ThreadPoolExecutor.runWorker
  [29] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [30] java.lang.Thread.run

--- 378793313 ns (0.15%), 24 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] jdk.internal.misc.Unsafe.park
  [ 2] java.util.concurrent.locks.LockSupport.park
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 377745348 ns (0.15%), 19 samples
  [ 0] __GI___pthread_mutex_lock
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [16] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [17] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [18] io.ktor.utils.io.ByteBufferChannel.flush
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [20] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [21] kotlinx.coroutines.DispatchedTask.run
  [22] java.util.concurrent.Executors$RunnableAdapter.call
  [23] java.util.concurrent.FutureTask.run
  [24] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [25] java.util.concurrent.ThreadPoolExecutor.runWorker
  [26] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [27] java.lang.Thread.run

--- 328489359 ns (0.13%), 10 samples
  [ 0] /usr/lib/x86_64-linux-gnu/libc-2.33.so
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 318385882 ns (0.13%), 20 samples
  [ 0] __pthread_cond_wait
  [ 1] [unknown]
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 307892458 ns (0.12%), 7 samples
  [ 0] __tls_get_addr
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [20] kotlinx.coroutines.DispatchedTask.run
  [21] java.util.concurrent.Executors$RunnableAdapter.call
  [22] java.util.concurrent.FutureTask.run
  [23] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [24] java.util.concurrent.ThreadPoolExecutor.runWorker
  [25] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [26] java.lang.Thread.run

--- 299998412 ns (0.12%), 30 samples
  [ 0] io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  [ 1] io.ktor.benchmarks.dispatchers.HotLoopDispatcher$$Lambda$35.539335468.run
  [ 2] java.lang.Thread.run

--- 277388396 ns (0.11%), 11 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.setState
  [ 1] java.util.concurrent.ThreadPoolExecutor$Worker.tryRelease
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 3] java.util.concurrent.ThreadPoolExecutor$Worker.unlock
  [ 4] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 5] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 6] java.lang.Thread.run

--- 276951194 ns (0.11%), 15 samples
  [ 0] jdk.internal.misc.Unsafe.park
  [ 1] java.util.concurrent.locks.LockSupport.park
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 255974729 ns (0.10%), 14 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 246069896 ns (0.10%), 20 samples
  [ 0] __GI___pthread_mutex_lock
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [16] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [17] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [19] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [20] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [21] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [22] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [23] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [24] kotlinx.coroutines.DispatchedTask.run
  [25] java.util.concurrent.Executors$RunnableAdapter.call
  [26] java.util.concurrent.FutureTask.run
  [27] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [28] java.util.concurrent.ThreadPoolExecutor.runWorker
  [29] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [30] java.lang.Thread.run

--- 236923066 ns (0.09%), 3 samples
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
  [ 2] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 6] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [ 9] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [10] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [11] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 236334970 ns (0.09%), 14 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 235717960 ns (0.09%), 14 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 4] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 5] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 6] java.lang.Thread.run

--- 226779918 ns (0.09%), 6 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 1] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 2] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 5] java.util.concurrent.locks.ReentrantLock.lock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [20] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [21] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [22] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [23] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [24] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [25] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [26] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [27] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [28] kotlinx.coroutines.DispatchedTask.run
  [29] java.util.concurrent.Executors$RunnableAdapter.call
  [30] java.util.concurrent.FutureTask.run
  [31] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [32] java.util.concurrent.ThreadPoolExecutor.runWorker
  [33] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [34] java.lang.Thread.run

--- 225659621 ns (0.09%), 16 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 215281121 ns (0.08%), 9 samples
  [ 0] __pthread_mutex_unlock_usercnt
  [ 1] [unknown]
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 213903624 ns (0.08%), 11 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.flush
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 205297298 ns (0.08%), 14 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.<init>
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [ 3] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] java.util.concurrent.Executors$RunnableAdapter.call
  [16] java.util.concurrent.FutureTask.run
  [17] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [18] java.util.concurrent.ThreadPoolExecutor.runWorker
  [19] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [20] java.lang.Thread.run

--- 204662269 ns (0.08%), 6 samples
  [ 0] java.util.concurrent.TimeUnit.convert
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 204127078 ns (0.08%), 9 samples
  [ 0] __GI___pthread_mutex_unlock
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [16] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [17] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [18] io.ktor.utils.io.ByteBufferChannel.flush
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [20] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [21] kotlinx.coroutines.DispatchedTask.run
  [22] java.util.concurrent.Executors$RunnableAdapter.call
  [23] java.util.concurrent.FutureTask.run
  [24] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [25] java.util.concurrent.ThreadPoolExecutor.runWorker
  [26] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [27] java.lang.Thread.run

--- 194319350 ns (0.08%), 7 samples
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
  [ 2] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 185304075 ns (0.07%), 14 samples
  [ 0] kotlin.coroutines.CombinedContext.fold
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 3] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 4] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 5] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 6] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [11] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 174082286 ns (0.07%), 11 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 173851228 ns (0.07%), 12 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 1] java.util.concurrent.locks.ReentrantLock.unlock
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 173767226 ns (0.07%), 7 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.getAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.flush
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 164854520 ns (0.06%), 15 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 164767868 ns (0.06%), 10 samples
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.completeRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 164370339 ns (0.06%), 11 samples
  [ 0] kotlinx.coroutines.internal.ThreadContextKt$countAll$1.invoke
  [ 1] kotlinx.coroutines.internal.ThreadContextKt$countAll$1.invoke
  [ 2] kotlin.coroutines.CombinedContext.fold
  [ 3] kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 5] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 6] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 7] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 8] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [12] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [13] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] java.util.concurrent.Executors$RunnableAdapter.call
  [17] java.util.concurrent.FutureTask.run
  [18] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [19] java.util.concurrent.ThreadPoolExecutor.runWorker
  [20] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [21] java.lang.Thread.run

--- 163619971 ns (0.06%), 4 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.flush
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 163276907 ns (0.06%), 6 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 2] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 3] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 4] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 5] java.lang.Thread.run

--- 163183246 ns (0.06%), 6 samples
  [ 0] java.lang.invoke.VarHandleInts$FieldInstanceReadWrite.compareAndSet
  [ 1] java.lang.invoke.VarHandleGuards.guard_LII_Z
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 3] java.util.concurrent.ThreadPoolExecutor$Worker.tryAcquire
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 5] java.util.concurrent.ThreadPoolExecutor$Worker.lock
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 154642882 ns (0.06%), 9 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.CancellableReusableContinuation.completeSuspendBlock
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 153817902 ns (0.06%), 12 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [15] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [16] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [17] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [19] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [20] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [21] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [22] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [23] kotlinx.coroutines.DispatchedTask.run
  [24] java.util.concurrent.Executors$RunnableAdapter.call
  [25] java.util.concurrent.FutureTask.run
  [26] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [27] java.util.concurrent.ThreadPoolExecutor.runWorker
  [28] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [29] java.lang.Thread.run

--- 153138181 ns (0.06%), 8 samples
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
  [ 1] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 2] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] java.util.concurrent.Executors$RunnableAdapter.call
  [ 6] java.util.concurrent.FutureTask.run
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 152986582 ns (0.06%), 6 samples
  [ 0] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 143209515 ns (0.06%), 9 samples
  [ 0] __pthread_enable_asynccancel
  [ 1] [unknown]
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 140000821 ns (0.06%), 14 samples
  [ 0] io.ktor.util.internal.LockFreeLinkedListNode.getNext
  [ 1] io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run

--- 133795718 ns (0.05%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 1] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 2] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 133406324 ns (0.05%), 6 samples
  [ 0] __GI___pthread_mutex_trylock
  [ 1] [unknown]
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 133401875 ns (0.05%), 9 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 133156544 ns (0.05%), 9 samples
  [ 0] java.nio.MappedByteBuffer.limit
  [ 1] java.nio.Buffer.<init>
  [ 2] java.nio.ByteBuffer.<init>
  [ 3] java.nio.ByteBuffer.<init>
  [ 4] java.nio.MappedByteBuffer.<init>
  [ 5] java.nio.DirectByteBuffer.<init>
  [ 6] java.nio.DirectByteBuffer.duplicate
  [ 7] io.ktor.util.BufferViewJvmKt.read
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 133143106 ns (0.05%), 8 samples
  [ 0] java.util.concurrent.locks.ReentrantLock$Sync.tryRelease
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 133020041 ns (0.05%), 8 samples
  [ 0] java.lang.invoke.VarHandleInts$FieldInstanceReadWrite.compareAndSet
  [ 1] java.lang.invoke.VarHandleGuards.guard_LII_Z
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 3] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 4] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly
  [ 6] java.util.concurrent.locks.ReentrantLock.lockInterruptibly
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 9] java.util.concurrent.ThreadPoolExecutor.getTask
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 132649582 ns (0.05%), 5 samples
  [ 0] sun.nio.ch.FileDispatcherImpl.read0
  [ 1] sun.nio.ch.FileDispatcherImpl.read
  [ 2] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 3] sun.nio.ch.IOUtil.read
  [ 4] sun.nio.ch.FileChannelImpl.read
  [ 5] io.ktor.util.BufferViewJvmKt.read
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 132466609 ns (0.05%), 9 samples
  [ 0] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 2] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 3] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 4] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.flush
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 122809590 ns (0.05%), 8 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] java.util.concurrent.Executors$RunnableAdapter.call
  [ 6] java.util.concurrent.FutureTask.run
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 122341205 ns (0.05%), 6 samples
  [ 0] sun.nio.ch.NativeThread.current
  [ 1] sun.nio.ch.NativeThreadSet.add
  [ 2] sun.nio.ch.FileChannelImpl.read
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 115194862 ns (0.05%), 8 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 113707658 ns (0.04%), 2 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [16] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [17] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [18] io.ktor.utils.io.ByteBufferChannel.flush
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [20] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [21] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [22] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [23] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [24] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [25] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [26] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [27] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [28] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [29] kotlinx.coroutines.DispatchedTask.run
  [30] java.util.concurrent.Executors$RunnableAdapter.call
  [31] java.util.concurrent.FutureTask.run
  [32] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [33] java.util.concurrent.ThreadPoolExecutor.runWorker
  [34] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [35] java.lang.Thread.run

--- 113628310 ns (0.04%), 8 samples
  [ 0] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 1] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 2] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 3] java.lang.Thread.run

--- 113300469 ns (0.04%), 2 samples
  [ 0] __pthread_cond_signal
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [20] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [21] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [22] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [23] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [24] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [25] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [26] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [27] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [28] kotlinx.coroutines.DispatchedTask.run
  [29] java.util.concurrent.Executors$RunnableAdapter.call
  [30] java.util.concurrent.FutureTask.run
  [31] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [32] java.util.concurrent.ThreadPoolExecutor.runWorker
  [33] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [34] java.lang.Thread.run

--- 112602631 ns (0.04%), 6 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 112560097 ns (0.04%), 4 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 1] java.util.concurrent.ThreadPoolExecutor$Worker.unlock
  [ 2] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 3] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 4] java.lang.Thread.run

--- 103386506 ns (0.04%), 9 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 103058661 ns (0.04%), 9 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 102434967 ns (0.04%), 7 samples
  [ 0] java.lang.invoke.VarHandleInts$FieldInstanceReadWrite.compareAndSet
  [ 1] java.lang.invoke.VarHandleGuards.guard_LII_Z
  [ 2] java.util.concurrent.FutureTask.set
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 102374760 ns (0.04%), 2 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
  [ 1] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] java.util.concurrent.Executors$RunnableAdapter.call
  [13] java.util.concurrent.FutureTask.run
  [14] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [15] java.util.concurrent.ThreadPoolExecutor.runWorker
  [16] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [17] java.lang.Thread.run

--- 102333091 ns (0.04%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 1] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 2] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] java.util.concurrent.Executors$RunnableAdapter.call
  [ 6] java.util.concurrent.FutureTask.run
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 102176249 ns (0.04%), 7 samples
  [ 0] java.util.concurrent.FutureTask.run
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 2] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 3] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 4] java.lang.Thread.run

--- 92807385 ns (0.04%), 2 samples
  [ 0] /usr/lib/x86_64-linux-gnu/libc-2.33.so
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 9] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [10] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [12] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [13] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [14] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [15] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [16] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [17] kotlinx.coroutines.DispatchedTask.run
  [18] java.util.concurrent.Executors$RunnableAdapter.call
  [19] java.util.concurrent.FutureTask.run
  [20] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [21] java.util.concurrent.ThreadPoolExecutor.runWorker
  [22] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [23] java.lang.Thread.run

--- 92415025 ns (0.04%), 6 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 92372212 ns (0.04%), 5 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 92308349 ns (0.04%), 3 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 92302761 ns (0.04%), 5 samples
  [ 0] clock_gettime
  [ 1] [unknown_Java]

--- 92100849 ns (0.04%), 6 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.getState
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 91769013 ns (0.04%), 5 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 1] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 2] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 5] java.util.concurrent.locks.ReentrantLock.lock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.access$flushImpl
  [18] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [19] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [20] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [21] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [22] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [23] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [24] kotlinx.coroutines.DispatchedTask.run
  [25] java.util.concurrent.Executors$RunnableAdapter.call
  [26] java.util.concurrent.FutureTask.run
  [27] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [28] java.util.concurrent.ThreadPoolExecutor.runWorker
  [29] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [30] java.lang.Thread.run

--- 82367626 ns (0.03%), 3 samples
  [ 0] [vdso]
  [ 1] [unknown_Java]

--- 82210846 ns (0.03%), 3 samples
  [ 0] jdk.internal.misc.Unsafe.checkPointer
  [ 1] jdk.internal.misc.Unsafe.checkPrimitivePointer
  [ 2] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 3] jdk.internal.misc.Unsafe.copyMemory
  [ 4] java.nio.DirectByteBuffer.get
  [ 5] java.nio.HeapByteBuffer.put
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 82168030 ns (0.03%), 5 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 82105354 ns (0.03%), 7 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 4] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 5] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 6] java.lang.Thread.run

--- 81991191 ns (0.03%), 7 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 1] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 81959817 ns (0.03%), 5 samples
  [ 0] kotlinx.coroutines.DispatchedTask.getExceptionalResult$kotlinx_coroutines_core
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 81672365 ns (0.03%), 3 samples
  [ 0] java.util.concurrent.Executors$RunnableAdapter.call
  [ 1] java.util.concurrent.FutureTask.run
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 3] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 4] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 5] java.lang.Thread.run

--- 81585856 ns (0.03%), 4 samples
  [ 0] jdk.internal.misc.Unsafe.unpark
  [ 1] java.util.concurrent.locks.LockSupport.unpark
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 4] java.util.concurrent.locks.ReentrantLock.unlock
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [11] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [12] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [13] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [14] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [15] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [16] io.ktor.utils.io.ByteBufferChannel.flush
  [17] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [18] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [19] kotlinx.coroutines.DispatchedTask.run
  [20] java.util.concurrent.Executors$RunnableAdapter.call
  [21] java.util.concurrent.FutureTask.run
  [22] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [23] java.util.concurrent.ThreadPoolExecutor.runWorker
  [24] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [25] java.lang.Thread.run

--- 72274247 ns (0.03%), 4 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 2] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 3] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 4] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 72033131 ns (0.03%), 5 samples
  [ 0] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 72015181 ns (0.03%), 5 samples
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.suspensionForSize
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 71785206 ns (0.03%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.getClosed
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.flush
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 71443269 ns (0.03%), 2 samples
  [ 0] pthread_cond_wait
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 71349173 ns (0.03%), 4 samples
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/libnio.so
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 63021721 ns (0.02%), 5 samples
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 2] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 61898239 ns (0.02%), 6 samples
  [ 0] io.ktor.utils.io.internal.CancellableReusableContinuation.parent
  [ 1] io.ktor.utils.io.internal.CancellableReusableContinuation.completeSuspendBlock
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 61763823 ns (0.02%), 4 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 2] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 3] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 4] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 5] java.lang.Thread.run

--- 61743378 ns (0.02%), 4 samples
  [ 0] itable stub
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 61239557 ns (0.02%), 3 samples
  [ 0] kotlinx.coroutines.DispatchedTask.run
  [ 1] java.util.concurrent.Executors$RunnableAdapter.call
  [ 2] java.util.concurrent.FutureTask.run
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 4] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 5] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 6] java.lang.Thread.run

--- 51783010 ns (0.02%), 1 sample
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] kotlinx.coroutines.CompletionStateKt.toState
  [ 2] kotlinx.coroutines.CompletionStateKt.toState$default
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.flush
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 51709935 ns (0.02%), 1 sample
  [ 0] sun.nio.ch.NativeThreadSet.add
  [ 1] sun.nio.ch.FileChannelImpl.read
  [ 2] io.ktor.util.BufferViewJvmKt.read
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 51698245 ns (0.02%), 5 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 51508736 ns (0.02%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.isClosedForRead
  [ 2] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] java.util.concurrent.Executors$RunnableAdapter.call
  [ 6] java.util.concurrent.FutureTask.run
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 51416846 ns (0.02%), 1 sample
  [ 0] kotlinx.coroutines.CompletionStateKt.toState
  [ 1] kotlinx.coroutines.CompletionStateKt.toState$default
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 3] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.flush
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 51412573 ns (0.02%), 1 sample
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 51339533 ns (0.02%), 1 sample
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.isPeriodic
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 2] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 3] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 4] java.lang.Thread.run

--- 51294788 ns (0.02%), 2 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [ 2] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 3] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 51258880 ns (0.02%), 4 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 4] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 5] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 6] java.lang.Thread.run

--- 51256448 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 3] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 4] kotlinx.coroutines.DispatchedTask.run
  [ 5] java.util.concurrent.Executors$RunnableAdapter.call
  [ 6] java.util.concurrent.FutureTask.run
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 51247964 ns (0.02%), 4 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 51147369 ns (0.02%), 4 samples
  [ 0] __GI___pthread_mutex_unlock
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [16] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [17] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [19] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [20] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [21] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [22] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [23] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [24] kotlinx.coroutines.DispatchedTask.run
  [25] java.util.concurrent.Executors$RunnableAdapter.call
  [26] java.util.concurrent.FutureTask.run
  [27] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [28] java.util.concurrent.ThreadPoolExecutor.runWorker
  [29] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [30] java.lang.Thread.run

--- 51061835 ns (0.02%), 4 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 51038697 ns (0.02%), 2 samples
  [ 0] __futex_abstimed_wait_cancelable64
  [ 1] [unknown]
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 51027602 ns (0.02%), 2 samples
  [ 0] java.util.concurrent.TimeUnit.convert
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 41380533 ns (0.02%), 4 samples
  [ 0] jdk.internal.misc.Unsafe.checkPrimitivePointer
  [ 1] jdk.internal.misc.Unsafe.copyMemoryChecks
  [ 2] jdk.internal.misc.Unsafe.copyMemory
  [ 3] java.nio.DirectByteBuffer.get
  [ 4] java.nio.HeapByteBuffer.put
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] java.util.concurrent.Executors$RunnableAdapter.call
  [14] java.util.concurrent.FutureTask.run
  [15] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [16] java.util.concurrent.ThreadPoolExecutor.runWorker
  [17] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [18] java.lang.Thread.run

--- 41269394 ns (0.02%), 1 sample
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.flush
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 8] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [10] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [11] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [12] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [13] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] java.util.concurrent.Executors$RunnableAdapter.call
  [17] java.util.concurrent.FutureTask.run
  [18] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [19] java.util.concurrent.ThreadPoolExecutor.runWorker
  [20] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [21] java.lang.Thread.run

--- 41221628 ns (0.02%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 1] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 2] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 3] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 41201395 ns (0.02%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 41131606 ns (0.02%), 2 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 41130920 ns (0.02%), 3 samples
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 41120923 ns (0.02%), 3 samples
  [ 0] java.nio.DirectByteBuffer.get
  [ 1] java.nio.HeapByteBuffer.put
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 41079954 ns (0.02%), 3 samples
  [ 0] jdk.internal.misc.Unsafe.unpark
  [ 1] java.util.concurrent.locks.LockSupport.unpark
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 4] java.util.concurrent.locks.ReentrantLock.unlock
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [11] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [12] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [13] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [14] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [15] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [16] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [17] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [19] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [20] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [21] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [22] kotlinx.coroutines.DispatchedTask.run
  [23] java.util.concurrent.Executors$RunnableAdapter.call
  [24] java.util.concurrent.FutureTask.run
  [25] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [26] java.util.concurrent.ThreadPoolExecutor.runWorker
  [27] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [28] java.lang.Thread.run

--- 41048682 ns (0.02%), 3 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 1] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] java.util.concurrent.Executors$RunnableAdapter.call
  [ 5] java.util.concurrent.FutureTask.run
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 41001275 ns (0.02%), 3 samples
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 40892971 ns (0.02%), 2 samples
  [ 0] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 40842886 ns (0.02%), 4 samples
  [ 0] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 1] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] java.util.concurrent.Executors$RunnableAdapter.call
  [13] java.util.concurrent.FutureTask.run
  [14] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [15] java.util.concurrent.ThreadPoolExecutor.runWorker
  [16] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [17] java.lang.Thread.run

--- 40832848 ns (0.02%), 3 samples
  [ 0] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 40818983 ns (0.02%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.getAndSet
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.flush
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 40814981 ns (0.02%), 3 samples
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.completeWrite
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesWritten
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesWrittenFromSession$ktor_io
  [ 4] io.ktor.utils.io.internal.WriteSessionImpl.written
  [ 5] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 40783854 ns (0.02%), 2 samples
  [ 0] java.nio.MappedByteBuffer.<init>
  [ 1] java.nio.DirectByteBuffer.<init>
  [ 2] java.nio.DirectByteBuffer.duplicate
  [ 3] io.ktor.util.BufferViewJvmKt.read
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 40742350 ns (0.02%), 2 samples
  [ 0] java.nio.Buffer.position
  [ 1] java.nio.ByteBuffer.position
  [ 2] java.nio.MappedByteBuffer.position
  [ 3] java.nio.MappedByteBuffer.position
  [ 4] java.nio.Buffer.<init>
  [ 5] java.nio.ByteBuffer.<init>
  [ 6] java.nio.ByteBuffer.<init>
  [ 7] java.nio.MappedByteBuffer.<init>
  [ 8] java.nio.DirectByteBuffer.<init>
  [ 9] java.nio.DirectByteBuffer.duplicate
  [10] io.ktor.util.BufferViewJvmKt.read
  [11] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 31159897 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 1] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 3] java.util.concurrent.locks.ReentrantLock.lock
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [10] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [11] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [12] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [13] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [14] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [15] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [16] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [17] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [18] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [19] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [20] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [21] kotlinx.coroutines.DispatchedTask.run
  [22] java.util.concurrent.Executors$RunnableAdapter.call
  [23] java.util.concurrent.FutureTask.run
  [24] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [25] java.util.concurrent.ThreadPoolExecutor.runWorker
  [26] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [27] java.lang.Thread.run

--- 31092876 ns (0.01%), 3 samples
  [ 0] java.lang.Thread.interrupted
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.checkInterruptWhileWaiting
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 31068850 ns (0.01%), 1 sample
  [ 0] __tls_get_addr@plt
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [20] kotlinx.coroutines.DispatchedTask.run
  [21] java.util.concurrent.Executors$RunnableAdapter.call
  [22] java.util.concurrent.FutureTask.run
  [23] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [24] java.util.concurrent.ThreadPoolExecutor.runWorker
  [25] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [26] java.lang.Thread.run

--- 30984389 ns (0.01%), 3 samples
  [ 0] __pthread_cond_wait
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.park
  [ 3] java.util.concurrent.locks.LockSupport.park
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 7] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 8] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 9] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [10] java.lang.Thread.run

--- 30925289 ns (0.01%), 1 sample
  [ 0] kotlinx.coroutines.AbstractTimeSourceKt.getTimeSource
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  [ 2] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 3] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 6] java.util.concurrent.locks.ReentrantLock.lock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [16] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [17] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [18] io.ktor.utils.io.ByteBufferChannel.flush
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [20] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [21] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [22] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [23] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [24] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [25] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [26] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [27] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [28] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [29] kotlinx.coroutines.DispatchedTask.run
  [30] java.util.concurrent.Executors$RunnableAdapter.call
  [31] java.util.concurrent.FutureTask.run
  [32] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [33] java.util.concurrent.ThreadPoolExecutor.runWorker
  [34] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [35] java.lang.Thread.run

--- 30901403 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
  [ 1] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 2] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [ 5] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [ 8] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [ 9] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [10] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] java.util.concurrent.Executors$RunnableAdapter.call
  [14] java.util.concurrent.FutureTask.run
  [15] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [16] java.util.concurrent.ThreadPoolExecutor.runWorker
  [17] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [18] java.lang.Thread.run

--- 30897592 ns (0.01%), 3 samples
  [ 0] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 2] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 3] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 30897484 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 2] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 30869771 ns (0.01%), 2 samples
  [ 0] sun.nio.ch.NativeThreadSet.add
  [ 1] sun.nio.ch.FileChannelImpl.read
  [ 2] io.ktor.util.BufferViewJvmKt.read
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 30868851 ns (0.01%), 3 samples
  [ 0] io.ktor.utils.io.internal.CancellableReusableContinuation.completeSuspendBlock
  [ 1] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] java.util.concurrent.Executors$RunnableAdapter.call
  [ 5] java.util.concurrent.FutureTask.run
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 30865596 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 30849566 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.<init>
  [ 2] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 3] kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
  [ 4] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.<init>
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 30812392 ns (0.01%), 1 sample
  [ 0] __pthread_disable_asynccancel
  [ 1] jdk.internal.misc.Unsafe.park
  [ 2] java.util.concurrent.locks.LockSupport.park
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 30799085 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
  [ 1] java.util.concurrent.locks.ReentrantLock$NonfairSync.tryAcquire
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire
  [ 3] java.util.concurrent.locks.ReentrantLock.lock
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [10] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [11] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [12] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [13] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [14] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [15] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [16] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [17] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [18] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [19] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [20] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [21] kotlinx.coroutines.DispatchedTask.run
  [22] java.util.concurrent.Executors$RunnableAdapter.call
  [23] java.util.concurrent.FutureTask.run
  [24] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [25] java.util.concurrent.ThreadPoolExecutor.runWorker
  [26] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [27] java.lang.Thread.run

--- 30784723 ns (0.01%), 2 samples
  [ 0] pthread_mutex_lock
  [ 1] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 2] jdk.internal.misc.Unsafe.unpark
  [ 3] java.util.concurrent.locks.LockSupport.unpark
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 5] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 6] java.util.concurrent.locks.ReentrantLock.unlock
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [12] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [13] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [14] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [16] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [17] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [18] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [19] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [20] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [21] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [22] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [23] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [24] kotlinx.coroutines.DispatchedTask.run
  [25] java.util.concurrent.Executors$RunnableAdapter.call
  [26] java.util.concurrent.FutureTask.run
  [27] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [28] java.util.concurrent.ThreadPoolExecutor.runWorker
  [29] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [30] java.lang.Thread.run

--- 30781827 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 30777729 ns (0.01%), 3 samples
  [ 0] __futex_abstimed_wait_cancelable64
  [ 1] jdk.internal.misc.Unsafe.park
  [ 2] java.util.concurrent.locks.LockSupport.park
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 30723696 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 2] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 3] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 4] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 5] java.lang.Thread.run

--- 30671627 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.valueCheck
  [ 1] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 2] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 3] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [10] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [11] kotlinx.coroutines.DispatchedTask.run
  [12] java.util.concurrent.Executors$RunnableAdapter.call
  [13] java.util.concurrent.FutureTask.run
  [14] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [15] java.util.concurrent.ThreadPoolExecutor.runWorker
  [16] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [17] java.lang.Thread.run

--- 30664147 ns (0.01%), 2 samples
  [ 0] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 30661138 ns (0.01%), 2 samples
  [ 0] Java_sun_nio_ch_FileDispatcherImpl_read0
  [ 1] sun.nio.ch.FileDispatcherImpl.read0
  [ 2] sun.nio.ch.FileDispatcherImpl.read
  [ 3] sun.nio.ch.IOUtil.readIntoNativeBuffer
  [ 4] sun.nio.ch.IOUtil.read
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 30658440 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 30635932 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.CancellableReusableContinuation.close
  [ 1] io.ktor.utils.io.ByteBufferChannel.close
  [ 2] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [ 3] io.ktor.utils.io.CoroutinesKt$launchChannel$1.invoke
  [ 4] kotlinx.coroutines.InvokeOnCompletion.invoke
  [ 5] kotlinx.coroutines.JobSupport.notifyCompletion
  [ 6] kotlinx.coroutines.JobSupport.completeStateFinalization
  [ 7] kotlinx.coroutines.JobSupport.finalizeFinishingState
  [ 8] kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath
  [ 9] kotlinx.coroutines.JobSupport.tryMakeCompleting
  [10] kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core
  [11] kotlinx.coroutines.AbstractCoroutine.resumeWith
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 30608365 ns (0.01%), 3 samples
  [ 0] kotlin.coroutines.CombinedContext.get
  [ 1] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 2] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 3] kotlinx.coroutines.DispatchedTask.run
  [ 4] java.util.concurrent.Executors$RunnableAdapter.call
  [ 5] java.util.concurrent.FutureTask.run
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 30598392 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.core.Buffer.getStartGap
  [ 1] io.ktor.utils.io.core.Buffer.resetForWrite
  [ 2] io.ktor.utils.io.core.IoBuffer.resetFromContentToWrite
  [ 3] io.ktor.utils.io.internal.WriteSessionImpl.request
  [ 4] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 30581576 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.writeSuspendPredicate
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$writeSuspendPredicate
  [ 2] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 3] io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
  [ 4] io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
  [ 5] io.ktor.utils.io.internal.WriteSessionImpl.tryAwait
  [ 6] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 30557195 ns (0.01%), 1 sample
  [ 0] /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  [ 1] [unknown]
  [ 2] java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
  [ 3] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [ 4] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [ 5] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [ 6] io.ktor.utils.io.ByteBufferChannel.flush
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 30514060 ns (0.01%), 1 sample
  [ 0] java.nio.DirectByteBuffer.<init>
  [ 1] java.nio.DirectByteBuffer.duplicate
  [ 2] io.ktor.util.BufferViewJvmKt.read
  [ 3] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 21292899 ns (0.01%), 1 sample
  [ 0] java.lang.Integer.valueOf
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 3] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 4] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 5] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 6] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [11] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 20775550 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 20749156 ns (0.01%), 1 sample
  [ 0] kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
  [ 1] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 2] kotlinx.coroutines.DispatchedTask.run
  [ 3] java.util.concurrent.Executors$RunnableAdapter.call
  [ 4] java.util.concurrent.FutureTask.run
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 20693327 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.CombinedContext.fold
  [ 1] kotlinx.coroutines.internal.ThreadContextKt.threadContextElements
  [ 2] kotlinx.coroutines.internal.DispatchedContinuation.<init>
  [ 3] kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
  [ 4] kotlin.coroutines.jvm.internal.ContinuationImpl.intercepted
  [ 5] kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
  [ 6] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [11] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [12] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [13] kotlinx.coroutines.DispatchedTask.run
  [14] java.util.concurrent.Executors$RunnableAdapter.call
  [15] java.util.concurrent.FutureTask.run
  [16] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [17] java.util.concurrent.ThreadPoolExecutor.runWorker
  [18] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [19] java.lang.Thread.run

--- 20669509 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 20655127 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
  [ 1] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 20631768 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 20611381 ns (0.01%), 1 sample
  [ 0] __tls_get_addr
  [ 1] jdk.internal.misc.Unsafe.unpark
  [ 2] java.util.concurrent.locks.LockSupport.unpark
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor
  [ 4] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 5] java.util.concurrent.locks.ReentrantLock.unlock
  [ 6] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.offer
  [ 7] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [10] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [11] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [12] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [13] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [14] io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
  [15] io.ktor.utils.io.ByteBufferChannel.resumeReadOp
  [16] io.ktor.utils.io.ByteBufferChannel.flushImpl
  [17] io.ktor.utils.io.ByteBufferChannel.flush
  [18] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [19] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [20] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invoke
  [21] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession$suspendImpl
  [22] io.ktor.utils.io.ByteBufferChannel.writeSuspendSession
  [23] io.ktor.util.cio.FileChannelsKt$readChannel$1.invokeSuspend
  [24] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [25] io.ktor.util.cio.FileChannelsKt$readChannel$1.invoke
  [26] io.ktor.utils.io.CoroutinesKt$launchChannel$job$1.invokeSuspend
  [27] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [28] kotlinx.coroutines.DispatchedTask.run
  [29] java.util.concurrent.Executors$RunnableAdapter.call
  [30] java.util.concurrent.FutureTask.run
  [31] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [32] java.util.concurrent.ThreadPoolExecutor.runWorker
  [33] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [34] java.lang.Thread.run

--- 20587285 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
  [ 1] kotlinx.coroutines.DispatchedTask.run
  [ 2] java.util.concurrent.Executors$RunnableAdapter.call
  [ 3] java.util.concurrent.FutureTask.run
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 20587177 ns (0.01%), 2 samples
  [ 0] java.lang.Thread.interrupted
  [ 1] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 2] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 3] java.lang.Thread.run

--- 20581729 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.ByteBufferChannel.access$getState
  [ 1] io.ktor.utils.io.ByteBufferChannel.readSuspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readSuspend
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 20581660 ns (0.01%), 1 sample
  [ 0] clock_gettime
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 5] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 6] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 7] java.lang.Thread.run

--- 20579247 ns (0.01%), 2 samples
  [ 0] kotlin.coroutines.jvm.internal.Boxing.boxInt
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 20569455 ns (0.01%), 1 sample
  [ 0] kotlin.ResultKt.throwOnFailure
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 5] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 6] kotlinx.coroutines.DispatchedTask.run
  [ 7] java.util.concurrent.Executors$RunnableAdapter.call
  [ 8] java.util.concurrent.FutureTask.run
  [ 9] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [10] java.util.concurrent.ThreadPoolExecutor.runWorker
  [11] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [12] java.lang.Thread.run

--- 20569029 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 3] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 4] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 5] kotlinx.coroutines.DispatchedTask.run
  [ 6] java.util.concurrent.Executors$RunnableAdapter.call
  [ 7] java.util.concurrent.FutureTask.run
  [ 8] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [ 9] java.util.concurrent.ThreadPoolExecutor.runWorker
  [10] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [11] java.lang.Thread.run

--- 20557851 ns (0.01%), 2 samples
  [ 0] java.nio.HeapByteBuffer.put
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 20557365 ns (0.01%), 1 sample
  [ 0] java.lang.Thread.blockedOn
  [ 1] java.lang.System$2.blockedOn
  [ 2] java.nio.channels.spi.AbstractInterruptibleChannel.blockedOn
  [ 3] java.nio.channels.spi.AbstractInterruptibleChannel.begin
  [ 4] sun.nio.ch.FileChannelImpl.beginBlocking
  [ 5] sun.nio.ch.FileChannelImpl.read
  [ 6] io.ktor.util.BufferViewJvmKt.read
  [ 7] io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
  [ 8] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 9] kotlinx.coroutines.DispatchedTask.run
  [10] java.util.concurrent.Executors$RunnableAdapter.call
  [11] java.util.concurrent.FutureTask.run
  [12] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [13] java.util.concurrent.ThreadPoolExecutor.runWorker
  [14] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [15] java.lang.Thread.run

--- 20554959 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.ReadWriteBufferState$Initial.getReadingState$ktor_io
  [ 1] io.ktor.utils.io.internal.ReadWriteBufferState$IdleNonEmpty.startReading$ktor_io
  [ 2] io.ktor.utils.io.internal.ReadWriteBufferState$IdleNonEmpty.startReading$ktor_io
  [ 3] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 4] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 9] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [10] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [11] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [12] kotlinx.coroutines.DispatchedTask.run
  [13] java.util.concurrent.Executors$RunnableAdapter.call
  [14] java.util.concurrent.FutureTask.run
  [15] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [16] java.util.concurrent.ThreadPoolExecutor.runWorker
  [17] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [18] java.lang.Thread.run

--- 20538823 ns (0.01%), 2 samples
  [ 0] io.ktor.utils.io.ByteBufferChannel.setupStateForRead
  [ 1] io.ktor.utils.io.ByteBufferChannel.access$setupStateForRead
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 5] io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
  [ 6] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 7] kotlinx.coroutines.DispatchedTask.run
  [ 8] java.util.concurrent.Executors$RunnableAdapter.call
  [ 9] java.util.concurrent.FutureTask.run
  [10] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [11] java.util.concurrent.ThreadPoolExecutor.runWorker
  [12] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [13] java.lang.Thread.run

--- 20537318 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.locks.ReentrantLock$Sync.tryRelease
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer.release
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease
  [ 3] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 6] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 7] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 8] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 9] java.lang.Thread.run

--- 20533892 ns (0.01%), 2 samples
  [ 0] jdk.internal.misc.Unsafe.park
  [ 1] java.lang.Thread.interrupted
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 20528927 ns (0.01%), 2 samples
  [ 0] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 1] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 2] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 5] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 6] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 7] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 8] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 9] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [10] kotlinx.coroutines.DispatchedTask.run
  [11] java.util.concurrent.Executors$RunnableAdapter.call
  [12] java.util.concurrent.FutureTask.run
  [13] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [14] java.util.concurrent.ThreadPoolExecutor.runWorker
  [15] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [16] java.lang.Thread.run

--- 20525604 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [ 5] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 6] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 7] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 8] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [12] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [13] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [14] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [15] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [16] kotlinx.coroutines.DispatchedTask.run
  [17] java.util.concurrent.Executors$RunnableAdapter.call
  [18] java.util.concurrent.FutureTask.run
  [19] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [20] java.util.concurrent.ThreadPoolExecutor.runWorker
  [21] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [22] java.lang.Thread.run

--- 20523848 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.locks.AbstractQueuedSynchronizer.findNodeFromTail
  [ 1] java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue
  [ 2] java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 4] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
  [ 5] java.util.concurrent.ThreadPoolExecutor.getTask
  [ 6] java.util.concurrent.ThreadPoolExecutor.runWorker
  [ 7] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [ 8] java.lang.Thread.run

--- 20501505 ns (0.01%), 1 sample
  [ 0] io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
  [ 1] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 2] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 3] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [ 4] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [ 5] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [ 6] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [ 7] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [ 8] kotlinx.coroutines.DispatchedTask.run
  [ 9] java.util.concurrent.Executors$RunnableAdapter.call
  [10] java.util.concurrent.FutureTask.run
  [11] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [12] java.util.concurrent.ThreadPoolExecutor.runWorker
  [13] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [14] java.lang.Thread.run

--- 20499940 ns (0.01%), 2 samples
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 3] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [ 4] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 5] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 6] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 7] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [11] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [13] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [14] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [15] kotlinx.coroutines.DispatchedTask.run
  [16] java.util.concurrent.Executors$RunnableAdapter.call
  [17] java.util.concurrent.FutureTask.run
  [18] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [19] java.util.concurrent.ThreadPoolExecutor.runWorker
  [20] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [21] java.lang.Thread.run

--- 20492659 ns (0.01%), 1 sample
  [ 0] java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
  [ 1] java.util.concurrent.ScheduledThreadPoolExecutor.schedule
  [ 2] java.util.concurrent.ScheduledThreadPoolExecutor.execute
  [ 3] kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
  [ 4] kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
  [ 5] io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
  [ 6] io.ktor.utils.io.ByteBufferChannel.bytesRead
  [ 7] io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
  [ 8] io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
  [ 9] io.ktor.utils.io.ByteBufferChannel.readAvailable
  [10] io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
  [11] io.ktor.utils.io.ByteBufferChannel.access$readAvailableSuspend
  [12] io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
  [13] kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
  [14] kotlinx.coroutines.DispatchedTask.run
  [15] java.util.concurrent.Executors$RunnableAdapter.call
  [16] java.util.concurrent.FutureTask.run
  [17] java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run
  [18] java.util.concurrent.ThreadPoolExecutor.runWorker
  [19] java.util.concurrent.ThreadPoolExecutor$Worker.run
  [20] java.lang.Thread.run

          ns  percent  samples  top
  ----------  -------  -------  ---
102204038974   40.22%    10215  io.ktor.benchmarks.dispatchers.IOCoroutineDispatcher$IOThread.run
 74293151454   29.24%     7427  java.util.concurrent.ConcurrentLinkedQueue.poll
 20560558017    8.09%     2056  io.ktor.benchmarks.dispatchers.HotLoopDispatcher.getQueue
 13894072536    5.47%      859  __GI___pthread_mutex_unlock
  7510313504    2.96%      751  io.ktor.benchmarks.dispatchers.HotLoopDispatcher.thread$lambda-0
  7020766061    2.76%      400  /usr/lib/jvm/java-11-openjdk-amd64/lib/server/libjvm.so
  5192927860    2.04%      273  __pthread_cond_signal
  3025600716    1.19%      130  read
  1542242171    0.61%      109  jlong_disjoint_arraycopy
  1127000603    0.44%       58  java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState
  1054055208    0.41%       47  __tls_get_addr
   930578370    0.37%       50  java.lang.invoke.VarHandleInts$FieldInstanceReadWrite.compareAndSet
   677192179    0.27%       31  [vdso]
   657480392    0.26%       25  java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.compareAndSet
   623815244    0.25%       39  __GI___pthread_mutex_lock
   594439814    0.23%       29  kotlinx.coroutines.internal.DispatchedContinuation.resumeWith
   573276397    0.23%       32  java.util.concurrent.locks.AbstractQueuedSynchronizer.findNodeFromTail
   533447441    0.21%       31  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.compareAndSet
   513521778    0.20%       38  java.lang.Thread.interrupted
   431307853    0.17%       13  /usr/lib/x86_64-linux-gnu/libc-2.33.so
   420804874    0.17%       29  itable stub
   349370271    0.14%       23  __pthread_cond_wait
   349360071    0.14%       28  io.ktor.utils.io.ByteBufferChannel.setupStateForRead
   338155181    0.13%       22  java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await
   306814009    0.12%       18  java.util.concurrent.locks.AbstractQueuedSynchronizer.release
   297485086    0.12%       17  jdk.internal.misc.Unsafe.park
   277465890    0.11%       17  kotlin.coroutines.jvm.internal.ContinuationImpl.getContext
   277388396    0.11%       11  java.util.concurrent.locks.AbstractQueuedSynchronizer.setState
   256467669    0.10%       18  io.ktor.utils.io.ByteBufferChannel.readAvailableSuspend
   255764426    0.10%       12  java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take
   255689871    0.10%        8  java.util.concurrent.TimeUnit.convert
   245900478    0.10%       14  java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue
   236022516    0.09%       17  java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.<init>
   216743939    0.09%       17  io.ktor.utils.io.ByteBufferChannel$readAvailableSuspend$2.invokeSuspend
   215281121    0.08%        9  __pthread_mutex_unlock_usercnt
   214586209    0.08%        8  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.getAndSet
   214385231    0.08%       11  io.ktor.util.cio.FileChannelsKt$readChannel$1$3$1.invokeSuspend
   205997402    0.08%       16  kotlin.coroutines.CombinedContext.fold
   197642811    0.08%       12  io.ktor.utils.io.ByteBufferChannel.readAsMuchAsPossible
   194627208    0.08%       10  io.ktor.benchmarks.FileBenchmarks$testKtorFileReadInFixed2FixedDispatcher$1.invokeSuspend
   185226327    0.07%        4  io.ktor.utils.io.ByteBufferChannel$writeSuspension$1.invoke
   184039584    0.07%        9  io.ktor.utils.io.internal.RingBufferCapacity.tryWriteAtLeast
   174772103    0.07%       12  kotlinx.coroutines.internal.ThreadContextKt$countAll$1.invoke
   174364837    0.07%       13  io.ktor.utils.io.ByteBufferChannel.resumeWriteOp
   173309495    0.07%       13  kotlinx.coroutines.ExecutorCoroutineDispatcherBase.dispatch
   164079096    0.06%       11  java.util.concurrent.locks.ReentrantLock$Sync.tryRelease
   143623210    0.06%        7  __GI___pthread_mutex_trylock
   143556313    0.06%        7  kotlinx.coroutines.internal.DispatchedContinuation.takeState$kotlinx_coroutines_core
   143342516    0.06%        9  jdk.internal.misc.Unsafe.unpark
   143209515    0.06%        9  __pthread_enable_asynccancel
   140000821    0.06%       14  io.ktor.util.internal.LockFreeLinkedListNode.getNext
   133156544    0.05%        9  java.nio.MappedByteBuffer.limit
   132649582    0.05%        5  sun.nio.ch.FileDispatcherImpl.read0
   122341205    0.05%        6  sun.nio.ch.NativeThread.current
   114110805    0.04%       10  kotlin.coroutines.CombinedContext.get
   113628310    0.04%        8  java.util.concurrent.ThreadPoolExecutor.getTask
   112884421    0.04%        6  clock_gettime
   103058661    0.04%        9  io.ktor.utils.io.ByteBufferChannel.bytesRead
   102486215    0.04%        7  java.util.concurrent.locks.AbstractQueuedSynchronizer.getState
   102374760    0.04%        2  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.accessCheck
   102333091    0.04%        3  io.ktor.utils.io.ByteBufferChannel.tryWriteSuspend$ktor_io
   102176249    0.04%        7  java.util.concurrent.FutureTask.run
    92605836    0.04%        7  kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith
    91989367    0.04%        5  kotlinx.coroutines.DispatchedTask.run
    91804532    0.04%        5  /usr/lib/jvm/java-11-openjdk-amd64/lib/libnio.so
    82579706    0.03%        3  sun.nio.ch.NativeThreadSet.add
    82210846    0.03%        3  jdk.internal.misc.Unsafe.checkPointer
    82107970    0.03%        2  io.ktor.utils.io.ByteBufferChannel.getClosed
    81959817    0.03%        5  kotlinx.coroutines.DispatchedTask.getExceptionalResult$kotlinx_coroutines_core
    81816426    0.03%        5  __futex_abstimed_wait_cancelable64
    81672365    0.03%        3  java.util.concurrent.Executors$RunnableAdapter.call
    72151543    0.03%        4  io.ktor.utils.io.ByteBufferChannel.getState
    71443269    0.03%        2  pthread_cond_wait
    61958982    0.02%        3  java.util.concurrent.locks.ReentrantLock$Sync.nonfairTryAcquire
    61898239    0.02%        6  io.ktor.utils.io.internal.CancellableReusableContinuation.parent
    61420133    0.02%        5  kotlinx.coroutines.internal.ThreadContextKt.updateThreadContext
    51416846    0.02%        1  kotlinx.coroutines.CompletionStateKt.toState
    51339533    0.02%        1  java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.isPeriodic
    51334479    0.02%        4  java.nio.DirectByteBuffer.get
    51294788    0.02%        2  java.util.concurrent.ScheduledThreadPoolExecutor.schedule
    51290302    0.02%        4  io.ktor.utils.io.internal.CancellableReusableContinuation.completeSuspendBlock
    51258880    0.02%        4  java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay
    51240005    0.02%        4  io.ktor.utils.io.ByteBufferChannel.flushImpl
    51101093    0.02%        4  java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute
    50979669    0.02%        3  java.nio.MappedByteBuffer.<init>
    41380533    0.02%        4  jdk.internal.misc.Unsafe.checkPrimitivePointer
    41273403    0.02%        4  kotlinx.coroutines.CoroutineDispatcher.interceptContinuation
    41236248    0.02%        3  io.ktor.utils.io.internal.RingBufferCapacity.tryReadAtMost
    41111590    0.02%        2  kotlinx.coroutines.AbstractTimeSourceKt.getTimeSource
    41025544    0.02%        3  java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.add
    41018927    0.02%        4  io.ktor.utils.io.ByteBufferChannel.readAvailable$suspendImpl
    41001275    0.02%        3  java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued
    40742350    0.02%        2  java.nio.Buffer.position
    31068850    0.01%        1  __tls_get_addr@plt
    30997677    0.01%        2  kotlin.coroutines.jvm.internal.ContinuationImpl.releaseIntercepted
    30897484    0.01%        1  kotlin.coroutines.jvm.internal.ContinuationImpl.<init>
    30860858    0.01%        2  java.lang.Thread.blockedOn
    30812392    0.01%        1  __pthread_disable_asynccancel
    30784723    0.01%        2  pthread_mutex_lock
    30703218    0.01%        2  kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt.intercepted
    30671627    0.01%        1  java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl.valueCheck
    30661138    0.01%        2  Java_sun_nio_ch_FileDispatcherImpl_read0
    30657495    0.01%        2  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node.predecessor
    30635932    0.01%        1  io.ktor.utils.io.internal.CancellableReusableContinuation.close
    30598392    0.01%        1  io.ktor.utils.io.core.Buffer.getStartGap
    30581576    0.01%        1  io.ktor.utils.io.ByteBufferChannel.writeSuspendPredicate
    30514060    0.01%        1  java.nio.DirectByteBuffer.<init>
    21292899    0.01%        1  java.lang.Integer.valueOf
    20723379    0.01%        2  java.nio.DirectByteBuffer.duplicate
    20581729    0.01%        1  io.ktor.utils.io.ByteBufferChannel.access$getState
    20579247    0.01%        2  kotlin.coroutines.jvm.internal.Boxing.boxInt
    20569455    0.01%        1  kotlin.ResultKt.throwOnFailure
    20557851    0.01%        2  java.nio.HeapByteBuffer.put
    20554959    0.01%        1  io.ktor.utils.io.internal.ReadWriteBufferState$Initial.getReadingState$ktor_io
    20488689    0.01%        1  kotlinx.coroutines.CoroutineDispatcher.releaseInterceptedContinuation
    20474395    0.01%        1  java.nio.Buffer.limit
    20457717    0.01%        1  java.lang.invoke.VarHandleGuards.guard_LII_Z
    20421266    0.01%        1  __vdso_clock_gettime
    20353093    0.01%        1  io.ktor.utils.io.ByteBufferChannel.flush
    10406332    0.00%        1  vtable stub
    10402766    0.00%        1  kotlinx.coroutines.internal.DispatchedContinuation.getContext
    10387482    0.00%        1  java.util.concurrent.atomic.AtomicInteger.get
    10383564    0.00%        1  io.ktor.utils.io.ByteBufferChannel.restoreStateAfterRead
    10369396    0.00%        1  kotlin.jvm.internal.Intrinsics.checkNotNull
    10359906    0.00%        1  unsafe_arraycopy
    10351428    0.00%        1  java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.setIndex
    10326406    0.00%        1  pthread_mutex_unlock
    10323888    0.00%        1  java.nio.ByteBuffer.limit
    10309910    0.00%        1  pthread_cond_wait@plt
    10279852    0.00%        1  pthread_self
    10271346    0.00%        1  jdk.internal.misc.Unsafe.checkOffset
    10260817    0.00%        1  java.util.concurrent.FutureTask.<init>
    10233121    0.00%        1  java.util.concurrent.locks.LockSupport.unpark
    10226994    0.00%        1  io.ktor.utils.io.ByteBufferChannel.access$getJoining$p
    10221711    0.00%        1  java.util.concurrent.ThreadPoolExecutor.runStateAtLeast
    10217627    0.00%        1  io.ktor.utils.io.ByteBufferChannel.access$flushImpl
    10217203    0.00%        1  io.ktor.utils.io.ByteBufferChannel.shouldResumeReadOp
    10213044    0.00%        1  java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.finishPoll
    10212159    0.00%        1  io.ktor.util.BufferViewJvmKt.read
    10207121    0.00%        1  java.nio.ByteBuffer.<init>
    10206588    0.00%        1  pthread_cond_signal
    10204845    0.00%        1  io.ktor.utils.io.internal.CancellableReusableContinuation.resumeWith
    10198517    0.00%        1  io.ktor.utils.io.ByteBufferChannel.carryIndex
    10196477    0.00%        1  java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.addConditionWaiter

